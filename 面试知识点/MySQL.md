# MySQL

## 1. 存储引擎

- ### InnoDB

  - InnoDB 是 MySQL 默认的事务型存储引擎，只要在需要它不支持的特性时，才考虑使用其他存储引擎。
  - InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。其默认级别时可重复读（REPEATABLE READ），在可重复读级别下，通过 MVCC + Next-Key Locking 防止幻读。
  - 主索引时聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对主键查询有很高的性能。
  - InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。
  - InnoDB 支持真正的在线热备份，MySQL 其他的存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合的场景中，停止写入可能也意味着停止读取。

- ### MyISAM

  - 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
  - 提供了大量的特性，包括压缩表、空间数据索引等。
  - 不支持事务。
  - 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。
  - 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。
  - 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。
  
- ### InnoDB 和 MyISAM 的比较

  - 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
  - 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
  - 外键：InnoDB 支持外键。
  - 备份：InnoDB 支持在线热备份。
  - 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
  - 其它特性：MyISAM 支持压缩表和空间数据索引。

## 2. 事务

- 事务是指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

- 事务最基本的莫过于 ACID 四个特性了，这四个特性分别是：

  - Atomicity：原子性
  - Consistency：一致性
  - Isolation：隔离性
  - Durability：持久性

- **原子性**：事务的最小工作单元，要么全成功，要么全失败。

- **一致性**：事务开始和结束后，数据库的完整性不会被破坏。

- **隔离性**：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。

- **持久性**：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失。

- ACID 之间的关系：事务的 ACID 特性概念很简单，但不好理解，主要是因为这几个特性不是一种平级关系：

  - 只有满足一致性，事务的结果才是正确的。
  - 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
  - 事务满足持久化是为了能应对数据库崩溃的情况。

  ![mysql_1](/Users/na/IdeaProjects/Technical summary/Image/mysql_1.webp)

## 3. 隔离级别

- **未提交读（READ UNCOMMITTED）**

  事务中的修改，即使没有提交，对其他事务也是可见的。

- **提交读（READ COMMITTED）**

  一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。

- **可重复读（REPEATABLE READ）**

  保证在同一个事务中多次读取同样数据的结果是一样的。

- **可串行化（SERIALIZABLE）**

  所有的数据库的读或者写操作都为串行执行，当前隔离级别下只支持单个请求同时执行，所有的操作都需要队列执行。所以种隔离级别下所有的数据是最稳定的，但是性能也是最差的。数据库的锁实现就是这种隔离级别的更小粒度版本。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 未提交读 |  √   |     √      |  √   |
|  提交读  |  ×   |     √      |  √   |
| 可重复读 |  ×   |     ×      |  √   |
| 可串行化 |  ×   |     ×      |  ×   |

## 4. 锁问题

- 脏读
  
  - 指的是一个事务可以读取到另一个事务未提交的数据。这种隔离级别岁最不安全的一种，因为未提交的事务是存在回滚的情况。
  - 例如：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
  
- 不可重复读

  - 指的是一个事务因为读取到另一个事务已提交的修改数据，导致在当前事务的不同时间读取同一条数据获取的结果不一致。
  - 例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。
  
  | **发生时间** | **SessionA**                         | **SessionB**                                              |
  | :----------- | :----------------------------------- | :-------------------------------------------------------- |
  | 1            | begin;                               |                                                           |
  | 2            | select * from user where id=1;(张三) |                                                           |
  | 3            |                                      | update user set name='李四' where id=1;(默认隐式提交事务) |
  | 4            | select * from user where id=1;(李四) |                                                           |
  | 5            |                                      | update user set name='王二' where id=1;(默认隐式提交事务) |
  | 6            | select * from user where id=1;(王二) |                                                           |
  
  - **在 InnoDB 存储引擎中，SELECT 操作的不可重复读问题通过 MVCC 得到了解决，而 UPDATE、DELETE 的不可重复读问题是通过 Record Lock 解决的，INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。**
  
- 幻读

  - 指在同一事务下，连续执行两次同样的 sql 语句可能返回不同的结果，第二次的 sql 语句可能会返回之前不存在的行。
  - 幻影读是一种特殊的不可重复读问题。
  
- 丢失更新

  - 一个事务的更新操作会被另一个事务的更新操作所覆盖。
  - 例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。
  - 这类型问题可以通过给 SELECT 操作加上排他锁来解决，不过这可能会引入性能问题，具体使用要视业务场景而定。
  
  ![mysql_4](/Users/na/IdeaProjects/Technical summary/Image/mysql_4.webp)

## 5. 锁

- 锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。
- 锁类型

  - **共享锁（S Lock）**：允许事务读一行数据
  - **排他锁（X Lock）**：允许事务删除或者更新一行数据
  - **意向共享锁（IS Lock）**：事务想要获得一张表中某几行的共享锁
  - **意向排他锁**：事务想要获得一张表中某几行的排他锁

## 6. MVCC

- 多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
- 