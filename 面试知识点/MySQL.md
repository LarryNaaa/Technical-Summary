# MySQL

[TOC]

## 1. 存储引擎

### 1.1 InnoDB

- InnoDB 是 MySQL 默认的事务型存储引擎，只要在需要它不支持的特性时，才考虑使用其他存储引擎。
- InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。其默认级别时可重复读（REPEATABLE READ），在可重复读级别下，通过 MVCC + Next-Key Locking 防止幻读。
- 主索引时聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对主键查询有很高的性能。
- InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。
- InnoDB 支持真正的在线热备份，MySQL 其他的存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合的场景中，停止写入可能也意味着停止读取。

### 1.2 MyISAM

  - 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
  - 提供了大量的特性，包括压缩表、空间数据索引等。
  - 不支持事务。
  - 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。
  - 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。
  - 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 1.3 InnoDB 和 MyISAM 的比较

  - 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
  - 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
  - 外键：InnoDB 支持外键。
  - 备份：InnoDB 支持在线热备份。
  - 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
  - 其它特性：MyISAM 支持压缩表和空间数据索引。

## 2. 事务

- 事务是指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

- **原子性**：**事物是一个不可分割的工作单位**，要么全成功，要么全失败。

- **一致性**：**数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性** 。

- **隔离性**：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。

- **持久性**：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失。

- ACID 之间的关系：事务的 ACID 特性概念很简单，但不好理解，主要是因为这几个特性不是一种平级关系：

  - 只有满足一致性，事务的结果才是正确的。
  - 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
  - 事务满足持久化是为了能应对数据库崩溃的情况。

  ![mysql_1](/Users/na/IdeaProjects/Technical summary/Image/mysql_1.webp)

## 3. 隔离级别：MySQL默认的隔离级别是**可重复读**

- **未提交读（READ UNCOMMITTED）**

  - 一个事务还没提交时，它做的变更就能被**别的事务看到**

  - 会出现幻读，不可重复读，脏读

  - 更新数据时加上**行级共享锁**，事物结束即释放

- **提交读（READ COMMITTED）**

  - 一个事务提交之后，它做的变更才会被其他事务看到 

  -  会出现幻读，不可重复读，不会出现脏读 

  -  写数据加**行级排他锁**，这样写过程是无法读取的，直到事务处理完毕才释放排他锁，给读的数据加**行级共享锁**，这样读的时候也是无法写的，但是**一旦读完该行就释放共享锁** 

  -  MySQL会在SQL语句开始执行时创建一个视图

- **可重复读（REPEATABLE READ）**

  - 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的 

  -  会出现幻读，不会出现不可重复读，脏读 

  -  给写的数据加**行级排他锁**，事务结束释放，给读的数据加行级共享锁，**事务结束后释放** 

  -  MySQL会在事物开始时创建一个一致性视图*(接下面的MVCC)*，事物结束时销毁

- **可串行化（SERIALIZABLE）**

  - 当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行
  
  - 不会出现幻读，不可重复读，脏读
  
  - 事务读数据则加**表级共享锁**，事务写数据则加**表级排他锁**
  
  - 不区分快照度与当前读

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 未提交读 |  √   |     √      |  √   |
|  提交读  |  ×   |     √      |  √   |
| 可重复读 |  ×   |     ×      |  √   |
| 可串行化 |  ×   |     ×      |  ×   |

## 4. 脏读，不可重复读和幻读

- 脏读
  
  - 一个事务读取了另一个事务**未提交**的数据，而这个数据是有可能回滚的。
  
- 不可重复读

  - 在数据库访问中，**一个事务范围**内**两个相同的查询**却返回了**不同**数据。这是由于查询时系统中其他事务修改的提交而引起的。
  
  - **在 InnoDB 存储引擎中，SELECT 操作的不可重复读问题通过 MVCC 得到了解决，而 UPDATE、DELETE 的不可重复读问题是通过 Record Lock 解决的，INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。**
  
- 幻读

  - 当一个事物对**整个table进行修改**之后，第二个事物向表中**插入**了一行数据，此时第一个事物发现了新插入的没有修改的数据行。
  

## 5. 锁

- 在数据库的增、删、改、查中，只有增、删、改才会加上排它锁，而只是查询并不会加锁，只能通过在select语句后显式加lock in share mode或者for update来加共享锁或者排它锁。
- 锁类型: 
  - 共享锁/读锁（Shared Locks）：针对同一份数据，多个读操作可以同时进行，即读加锁，不能写并且可并行读
  
  - 排他锁/写锁（Exclusive Locks）：针对写操作，假如当前写操作没有完成，那么它会阻断其它的写锁和读锁，即写加锁，其它读写都阻塞 。
  
  - 间隙锁：`Gap Locks`和`Next-Key Locks`。Gap Locks锁定索引之间的间隙，但是不包含索引本身。Next-Key Locks是Gap Locks+Record Locks形成闭区间锁，不仅锁定一个记录上的索引，也锁定索引之间的间隙。
  
  - 行锁（Record Locks）：锁定当前数据行，锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高，行锁也是MyISAM和InnoDB的区别之一，InnoDB支持行锁并且支持事务 。
  
  - 表锁：表锁则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低。
  
  - 悲观锁：
    - 先获取锁，再进行业务操作。
    - 通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。
    - MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。
    
  - 乐观锁：
    
    - 也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。
    
    - 乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。
    
    - 一般的做法是**在需要锁的数据上增加一个版本号，或者时间戳**，
    
      **实现方式举例如下：**
    
      **乐观锁（给表加一个版本号字段）** 这个并不是乐观锁的定义，给表加版本号，是**数据库实现乐观锁的一种方式**。
    
      1. SELECT data AS old_data, version AS old_version FROM …;
      2. 根据获取的数据进行业务操作，得到new_data和new_version
      3. UPDATE SET data = new_data, version = new_version WHERE version = old_version
    
      ```sql
      if (updated row > 0) {
      
      // 乐观锁获取成功，操作完成
      
      } else {
      
      // 乐观锁获取失败，回滚并重试
      
      }
      ```
    
  - 悲观锁和乐观锁使用区别：
  
    - **响应速度：** 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。'
    - **冲突频率：** 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。
    - **重试代价：** 如果重试代价大，建议采用悲观锁。

## 6. 三大范式

- 第一范式： 所有字段值都是不可分解的原子值 。
  - 例如有一个列是电话号码一个人可能有一个办公电话一个移动电话。第一范式就需要拆开成两个属性。 
- 第二范式：非主属性完全函数依赖于候选键。
  - 如PersonID，ProductID，ProductName，PersonName可以看到，OrderID和ProductID是联合主键，但是ProductName是依赖于ProductID的，只依赖了部分主键，没有依赖全部主键。需要拆分成三个表：PersonID, PersonName,ProductID, ProductName和PersonID, ProductID 
-  第三范式： 每一列数据都和主键直接相关，而不能间接相关。
  -  如OrderID，ProductID，ProductName，OrderID是主键，但是ProductID依赖了OrderID，而ProductName依赖了ProductID，等于说是间接依赖了OrderID，所以需要拆分为两个表：OrderID, ProductID和ProductID, ProductName

## 7. MySQL 索引

- 索引是帮助MySQL**高效获取数据**的**数据结构**，能**加快数据库的查询速度**，**是存储在磁盘上的文件中的**

- **优势：**

  - **可以提高数据检索的效率，降低数据库的IO成本**，类似于书的目录。

  - 通过**索引列对数据进行排序**，降低数据排序的成本，降低了CPU的消耗。

  - - 被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。
    - 如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。

  **劣势：**

  - **索引会占据磁盘空间**
  - **索引虽然会提高查询效率，但是会降低更新表的效率**。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。
  
### 7.1 索引类型

  - 主键索引：索引列中的值必须是唯一的，不允许有空值。
  - 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
  - 唯一索引：索引列中的值必须是唯一的，但是允许为空值。
  - 哈希索引：**哈希索引就是采用一定的哈希算法**，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快：
    - 无法用于排序与分组；
    - 只支持精确查找，无法用于部分查找和范围查找。
    - InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
  - 全文索引：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
  - 空间索引：MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。
  - 前缀索引：在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。
  - 其他(按索引列数量分类)：单列索引和组合索引。组合索引的使用，需要遵循**最左前缀匹配原则（最左匹配原则）**。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。

### 7.2 B+树索引和hash索引的区别     

  -  B+树索引适合返回查找，而hash索引适合等值查询 

  -  hash索引无法利用索引完成[排序]()，但是B+树索引可以 

  -  hash索引不支持联合索引的最左匹配规则，但是B+树索引支持 

  -  如果有大量重复键值的情况下，因为存在hash碰撞，hash索引的效率会很低

### 7.3 **MyISAM索引**：非聚簇索引

  - MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。
  
  - 主键索引
    
    - **根据主键等值查询数据：**
    
    ![MySQL_8](/Users/na/IdeaProjects/Technical summary/Image/MySQL_8.webp)
    
    - **根据主键范围查询数据：**
    
    ![MySQL_9](/Users/na/IdeaProjects/Technical summary/Image/MySQL_9.webp)
    
  - 辅助索引
  
    - 在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。
    - 查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。

### 7.4 InnoDB索引：聚簇索引

  - **InnoDB的数据和索引存储在一个文件t_user_innodb.ibd中。InnoDB的数据组织方式，是聚簇索引。主键索引的叶子节点会存储数据行，辅助索引只会存储主键值。**

#### 7.4.1 主键索引

- 每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。InnoDB创建索引的具体规则如下：

  > 1. 在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。
  > 2. 如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。
  > 3. 如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。

![MySQL_10](/Users/na/IdeaProjects/Technical summary/Image/MySQL_10.png)

#### 7.4.2 辅助索引：

- 除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键的值。因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找，这个过程也被称作回表查询。

- 底层叶子节点的按照（age，id）的顺序排序，先按照age列从小到大排序，age列相同时按照id列从小到大排序。
- 使用辅助索引需要检索两遍索引：首先检索辅助索引获得主键，然后使用主键到主索引中检索获得记录。

![MySQL_11](/Users/na/IdeaProjects/Technical summary/Image/MySQL_11.webp)

#### 7.4.3 组合索引

- 因为每个select只能选择一个索引，当where条件过多时，考虑建立联合索引，即把多个列作为索引。

- **组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(>、<、between、like)就停止匹配。**

- 对于索引(a,b,c)，引擎会先按照a排序，当a相等时，再按照b排序，当b相等时，再按照c排序

   对于索引(a,b,c)来说，能命中的where语句有 

  1.  where a = 1,where a = 1 and b = 1和where a = 1 and b = 1 and c = 1 
  2.  where a like '1%'，对于这个，可能会引出前缀索引

- 在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。

- 就像下面的查询，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。

- 可以说创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引。

![MySQL_12](/Users/na/IdeaProjects/Technical summary/Image/MySQL_12.webp)

#### 7.4.4 前缀索引 

- 因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 

- 流程是： 

   1. 先计算完整列的选择性 

   ```sql
select count(distinct col_1)/count(1) from table_1
  ```
  
  2. 再计算不同前缀长度的选择性 

  ```sql
select count(distinct left(col_1,4))/count(1) from table_1
  ```
  
  3. 找到最优长度之后，创建前缀索引 

  ```sql
create index idx_front on table_1 (col_1(4))
  ```

#### 7.4.5 覆盖索引

- **如果一个索引包含所有需要查询的字段的值，则称之为覆盖索引。**因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是**覆盖索引**。


### 7.5 聚簇索引与非聚簇索引的区别

- 聚簇索引和非聚簇索引是建立在B+树的基础上 
- 聚簇索引：key为主键，value为其余列的数据。一个表只能有一个聚簇索引；非聚簇索引：除了聚簇索引外的都叫非聚簇索引 
- 对于MyISAM的主键索引来说，它的非聚簇索引是key为主键，value为行号*(不一定)* 
- 对于MyISAM的二级索引来说，它的非聚簇索引是key为其他列，value为行号*(不一定)* 
- 对于InnoDB的二级索引来说，它的非聚簇索引是key为其他列，value是主键 
- 非聚簇索引也叫二级索引 
- 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号） 
- 对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为**回表**。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 
- 通常情况下， 主键索引查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可 
-  注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引

### 7.6 MySQL性能优化：索引下推(index condition pushdown, ICP)

- 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。
- 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。
- 在InnoDB中只针对二级索引有效
- **索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。**
- MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。

### 7.7 查询在什么情况下不走索引

- 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 

  1.  根据搜索条件，找出所有可能使用的索引 
  2.  计算全表扫描的代价 
  3.  计算使用不同索引执行查询的代价 
  4.  对比各种执行方案的代价，找出成本最低的那一个

- 假设索引为(a,b,c) 

  -  ASC和DESC索引混合使用的[排序]()：select * from tab order by a, b desc limit 10; 
-  违背最左前缀原则：select * from tab where b = '1'; 
  -  WHERE⼦句中出现非[排序]()使⽤到的索引列：select * from tab d = '1' order by a limit 10; 
-  [排序]()列包含非同⼀个索引的列：select * from tab order by a, d limit 10; 
  -  WHERE子句中出现计算：select * from tab where a * 4 = 2; 
-  WHERE子句中出现null值：select * from tab where a = null; 
  -  WHERE子句中使用!=或<>操作符：select * from tab where a != 1; 


### 7.8 MySQL如何为表字段添加索引

- 在已建表中添加索引

```sql
CREATE INDEX indexName ON table_name (column_name)
```

- 修改表结构添加索引

```sql
添加主键索引:
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。

添加唯一索引:
ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。

添加普通索引:
ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。

添加全文索引(适用于MyISAM，InnoDB 5.6+):
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。

添加联合索引:
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

- 创建表时直接指定

```sql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```

- 删除索引的语法

```sql
DROP INDEX [indexName] ON mytable; 
```

### 7.9 如何选择索引

- 只为⽤于搜索、[排序]()或分组的列创建索引 
- 考虑列的基数 ，基数越大，创建索引的效果越好 
- 索引列的类型尽量⼩，这样B+树中每个页存储的数据就会更多 
- 写多读少尽量不要建立索引 
- 可以使用倒叙索引或者hash索引 
- InnoDB的主键尽量用MySQL的自增主键

![MySQL_16](/Users/na/IdeaProjects/Technical summary/Image/MySQL_16.jpg)

### 7.10 唯一索引和普通索引选择哪个？

- 唯一索引和普通索引在读取的时候效率基本差不多，普通索引差了一点点。主要是判断和特殊情况下的一次IO 
- 写入的时候，普通索引可以利用change buffer，适合写多读少，比唯一索引要快 
- 以业务为前提，如果要求唯一，就要选择唯一索引。如果已经保证列的唯一，我们尽量选择普通索引，然后把change buffer调大

### 7.11 怎么查看MySQL语句有没有用到索引

- 通过explain，如 

  | 1    | EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26'; |
  | ---- | ------------------------------------------------------------ |
  |      |                                                              |

  | id   | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref               | filtered | rows | Extra |
  | ---- | ----------- | ------ | ---------- | ----- | ------------- | ------- | ------- | ----------------- | -------- | ---- | ----- |
  | 1    | SIMPLE      | titles | null       | const | PRIMARY       | PRIMARY | 59      | const,const,const | 10       | 1    |       |

- explain命令输出的结果有10列：`id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra`

- id：包含一组数字，表示查询中执行SELECT子句或操作表的**顺序**。在id列上也会有几种情况：

  - 如果id相同执行顺序由上至下。
  - 如果id不相同，id的序号会递增，id值越大优先级越高，越先被执行。(一般有子查询的SQL语句id就会不同)

- **select_type**：表示select查询的类型，select_type属性下有好几种类型：

  - **SIMPLLE**：简单查询，该查询不包含 UNION 或子查询
  - **PRIMARY**：如果查询包含UNION 或子查询，则**最外层的查询**被标识为PRIMARY
  - UNION：表示此查询是 UNION 中的第二个或者随后的查询
  - DEPENDENT：UNION 满足 UNION 中的第二个或者随后的查询，其次取决于外面的查询
  - UNION RESULT：UNION 的结果
  - **SUBQUERY**：子查询中的第一个select语句(该子查询不在from子句中)
  - DEPENDENT SUBQUERY：子查询中的 第一个 select，同时取决于外面的查询
  - **DERIVED**：包含在from子句中子查询(也称为派生表)
  - UNCACHEABLE SUBQUERY：满足是子查询中的第一个 select 语句，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中
  - UNCACHEABLE UNION：满足此查询是 UNION 中的第二个或者随后的查询，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中

- table：table表示查询涉及的表或衍生的表

- **type**：通过 type 字段，我们判断此次查询是 全表扫描 还是 索引扫描等。

  - `system`: 表中只有一条数据， 这个类型是特殊的 const 类型。 const: 针对主键或唯一索引的等值查询扫描，最多只返回一行数据。 const 查询速度非常快， 因为它仅仅读取一次即可。例如下面的这个查询，它使用了主键索引，因此 type 就是 const 类型的：explain select * from user_info where id = 2；
  - `const`: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.
  - `eqref`: 此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果。并且查询的比较操作通常是 =，查询效率较高。例如：explain select * from userinfo, orderinfo where userinfo.id = orderinfo.userid;
  - `ref`: 此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引，或者是使用了 最左前缀 规则索引的查询。例如下面这个例子中， 就使用到了 ref 类型的查询：explain select * from userinfo, orderinfo where userinfo.id = orderinfo.userid AND orderinfo.user_id = 5
  - `range`: 表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中。例如下面的例子就是一个范围查询：explain select * from user_info where id between 2 and 8；
  - `index`: 表示全索引扫描(full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引， 而不扫描数据。index 类型通常出现在：所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。当是这种情况时，Extra 字段 会显示 Using index。
  - `ALL`: 表示全表扫描，这个类型的查询是性能最差的查询之一。通常来说， 我们的查询不应该出现 ALL 类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难。 如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免。
  - 通常来说, 不同的 type 类型的性能关系如下：`ALL < index < range ~ indexmerge < ref < eqref < const < system` ALL 类型因为是全表扫描， 因此在相同的查询条件下，它是速度最慢的。而 index 类型的查询虽然不是全表扫描，但是它扫描了所有的索引，因此比 ALL 类型的稍快.后面的几种类型都是利用了索引来查询数据，因此可以过滤部分或大部分数据，因此查询效率就比较高了。

- **possible_key**：它表示 mysql 在查询时，可能使用到的索引。 注意，即使有些索引在 possible_keys 中出现，但是并不表示此索引会真正地被 mysql 使用到。 mysql 在查询时具体使用了哪些索引，由 key 字段决定。

- **key**：在当前查询时所真正使用到的索引

- **key_len**：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用。

  - key_len 的计算规则如下:
    - 字符串
      - char(n): n 字节长度
      - varchar(n): 如果是 utf8 编码, 则是 3 *n + 2字节; 如果是 utf8mb4 编码, 则是 4* n + 2 字节.
    - 数值类型:
      - TINYINT: 1字节
      - SMALLINT: 2字节
      - MEDIUMINT: 3字节
      - INT: 4字节
      - BIGINT: 8字节
    - 时间类型
      - DATE: 3字节
      - TIMESTAMP: 4字节
      - DATETIME: 8字节
    - 字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.

- ref：这个表示显示索引的哪一列被使用了，如果可能的话,是一个常量。前文的type属性里也有ref，注意区别。

- **rows**：rows 也是一个重要的字段，mysql 查询优化器根据统计信息，估算 sql 要查找到结果集需要扫描读取的数据行数，这个值非常直观的显示 sql 效率好坏， 原则上 rows 越少越好。

- **extra**：explain 中的很多额外的信息会在 extra 字段显示, 常见的有以下几种内容:

  - `using filesort` ：表示 mysql 需额外的排序操作，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大。
  - `using index`：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
  - `using temporary`：查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。
  - `using where` ：表名使用了where过滤。

## 8. B+树索引

- 二叉查找树(BST)：不平衡
  - 二叉查找树(BST，Binary Search Tree)，也叫二叉排序树，在二叉树的基础上需要满足：任意节点的左子树上所有节点值不大于根节点的值，任意节点的右子树上所有节点值不小于根节点的值。
  - 因为此时查询时间取决于树高，平均时间复杂度是O(lgn)。然而，BST可能长歪而变得不平衡，此时BST退化为链表，时间复杂度退化为O(n)。
  
- 平衡二叉树(AVL)：旋转耗时
  
  - 一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。所以 AVL 树适用于插入/删除次数比较少，但查找多的场景。
  
- 红黑树：树太高
  - 通过对从根节点到叶子节点路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。适合，查找少，插入/删除次数多的场景。
  - 对于数据在内存中的情况（TreeMap和HashMap），红黑树的表现是非常优异的。但是对于数据在磁盘等辅助存储设备中的情况（如MySQL等数据库），红黑树并不擅长，因为红黑树长得还是太高了。当数据在磁盘中时，磁盘IO会成为最大的性能瓶颈，设计的目标应该是尽量减少IO次数；而树的高度越高，增删改查所需要的IO次数也越多，会严重影响性能。
  
- B树：为磁盘而生
  
  - B树也称B-树(其中-不是减号)，是多叉平衡查找树，与二叉树相比，B树的每个非叶节点可以有多个子树。因此，当总节点数量相同时，B树的高度远远小于AVL树和红黑树(B树是一颗“矮胖子”)，磁盘IO次数大大减少。
  - 主要特点：
  1. B树的节点中存储着多个元素，每个内节点有多个分叉。
    2. 节点中的元素包含键值和数据，节点中的键值从小到大排列。也就是说，在所有的节点都储存数据。
    3. 父节点当中的元素不会出现在子节点中。
    4. 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。
  - B树的问题：
    - B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
    - 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。
  
  ![MySQL_5](/Users/na/IdeaProjects/Technical summary/Image/MySQL_5.webp)
  
- B+树

  - B+树也是多叉平衡查找树，其与B树的区别主要在于：
    - B树中每个节点（包括叶节点和非叶节点）都存储数据，B+树中只有叶子节点存储数据，非叶节点只存储键值。
    - 内部节点中的 key 都按照从小到大的顺序排列，对于内部节点中的一个 key，左子树中的所有 key 都小于它，右子树中的 key 都大于等于它，叶子节点的记录也是按照从小到大排列的。
    - 叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。
    - B树中一条记录只会出现一次，不会重复出现，而B+树的键则可能重复重现——一定会在叶节点出现，也可能在非叶节点重复出现。
    - B树中的非叶节点，记录数比子节点个数少1；而B+树中记录数与子节点个数相同。
    - **可以看到B+树可以保证等值和范围查询的快速查找，MySQL的索引就采用了B+树的数据结构。**
    - **等值查询**：
    
    ![MySQL_6](/Users/na/IdeaProjects/Technical summary/Image/MySQL_6.webp)
    
    - **范围查询：**
    
    ![MySQL_7](/Users/na/IdeaProjects/Technical summary/Image/MySQL_7.png)
    
  - B+树与B树比较：
    - 更少的IO次数：B+树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比B数多很多（即阶m更大），因此B+树的高度更低，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高。
    - 更适于范围查询：在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要对链表进行遍历即可。
    - 更稳定的查询效率：B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
    
  - B+树也存在劣势：由于键会重复出现，因此会占用更多的空间。
## 9. LBCC

- **LBCC，基于锁的并发控制，Lock Based Concurrency Control。**
- 使用锁的机制，在当前事务需要对数据修改时，将当前事务加上锁，同一个时间只允许一条事务修改当前数据，其他事务必须等待锁释放之后才可以操作。

## 10. MVCC

- 多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
- **MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力**。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)。
- InnoDB存储引擎保存的MVCC的数据

  - InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。**一个保存了行的事务ID（DB_TRX_ID），一个保存了行的回滚指针（DB_ROLL_PT）**。每开始一个新的事务，都会自动递增产 生一个新的事务id。事务开始时刻的会把事务id放到当前事务影响的行事务id中，当查询时需要用当前事务id和每行记录的事务id进行比较。
  - **MVCC 在mysql 中的实现依赖的是 undo log 与 read view 。**
  - 对于 **RU(READ UNCOMMITTED)** 隔离级别下，所有事务直接读取数据库的最新值即可，和 **SERIALIZABLE** 隔离级别，所有请求都会加锁，同步执行。所以这对这两种情况下是不需要使用到 **Read View** 的版本控制。
  - 对于 **RC(READ COMMITTED)** 和 **RR(REPEATABLE READ)** 隔离级别的实现就是通过上面的版本控制来完成。两种隔离界别下的核心处理逻辑就是判断所有版本中哪个版本是当前事务可见的处理。针对这个问题InnoDB在设计上增加了**ReadView**的设计，**ReadView**中主要包含当前系统中还有哪些活跃的读写事务
  - 在 READ COMMITTED 中每次查询都会生成一个实时的 ReadView，做到保证每次提交后的数据是处于当前的可见状态。
  - 而 REPEATABLE READ 中，在当前事务第一次查询时生成当前的 ReadView，并且当前的 ReadView 会一直沿用到当前事务提交，以此来保证可重复读（REPEATABLE READ）。
- undo log
  - Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。
  - `undo log`主要有两个作用：回滚和多版本控制(MVCC)
  - `undo log`主要存储的也是逻辑日志，比如我们要`insert`一条数据了，那`undo log`会记录的一条对应的`delete`日志。我们要`update`一条记录时，它会记录一条对应**相反**的update记录。
  - 因为`undo log`存储着修改之前的数据，相当于一个**前版本**，MVCC实现的是读写不阻塞，读的时候只要返回前一个版本的数据就行了。

## 11. **数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）**

### 11.1 binlog

- `binlog`记录了数据库表结构和表数据变更，存储着每条变更的`SQL`语句，不会记录`select`
- 主要有两个作用：**复制和恢复数据**
  - 主从服务器需要保持数据的一致性，通过`binlog`来同步数据。
  - 如果整个数据库的数据都被删除了，`binlog`存储着所有的数据变更情况，那么可以通过`binlog`来对数据进行恢复。

### 11.2 redo log

-  记录了数据操作在物理层面的修改，如果写入内存成功，但数据还没真正刷到磁盘，如果此时的数据库挂了，我们可以靠`redo log`来恢复内存的数据，这就实现了持久性
-  `redo log`的作用是为**持久化**而生的。写完内存，如果数据库挂了，那我们可以通过`redo log`来恢复内存还没来得及刷到磁盘的数据，将`redo log`加载到内存里边，那内存就能恢复到挂掉之前的数据了。`redo log` 存储的是物理数据的变更，如果我们内存的数据已经刷到了磁盘了，那`redo log`的数据就无效了。所以`redo log`不会存储着**历史**所有数据的变更，**文件的内容会被覆盖的**。

### 11.3 binlog和redo log区别

- redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，记录的是`update/delete/insert`这样的SQL语句
- redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用
- binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用
- redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志
- MySQL通过**两阶段提交**来保证`redo log`和`binlog`的数据是一致的。过程：
  - 阶段1：InnoDB`redo log` 写盘，InnoDB 事务进入 `prepare` 状态
  - 阶段2：`binlog` 写盘，InooDB 事务进入 `commit` 状态
  - 每个事务`binlog`的末尾，会记录一个 `XID event`，标志着事务是否提交成功，也就是说，恢复过程中，`binlog` 最后一个 XID event 之后的内容都应该被 purge。

## 12. sql语法

- select 查询结果    如: [学号,平均成绩：组函数avg(成绩)]
- from 从哪张表中查找数据   如:[涉及到成绩：成绩表score]
- where 查询条件    如:[b.课程号='0003' and b.成绩>80]
- group by 分组    **使用GROUP BY子句时，SELECT子句中只能有聚合键、聚合函数、常数。**

```sql
select emp_no, count(salary) as t
from salaries
group by emp_no
having count(salary) > 15
```

- having 对分组结果指定条件    如:[大于60分]
- order by 对查询结果排序    如:[增序: 成绩  ASC / 降序: 成绩 DESC];
- limit   使用limt子句返回topN（对应这个问题返回的成绩前两名）如:[ limit  2 ==>从0索引开始读取2个]
  limit==>从0索引开始 [0,N-1]

```sql
select * from employees order by hire_date desc limit 2,1;
```

- 组函数: 去重 distinct()  统计总数sum()   计算个数count()  平均数avg()  最大值max() 最小数min() 

- 多表连接: 内连接(省略默认inner) join ...on..左连接left join tableName as b on a.key ==b.key右连接right join  连接union(无重复(过滤去重))和union all(有重复[不过滤去重])

  ```sql
  select s.*, d.dept_no
  from dept_manager as d
  left join salaries as s
  on d.emp_no =  s.emp_no
  order by s.emp_no asc
  ```

- 内连接INNER JOIN求两个表的**交集**

- 左连接LEFT JOIN的含义就是求两个表A表和B表的**交集外加左表剩下的数据**。

- 右连接RIGHT JOIN就是求两个表**A和B表的交集外加右表B剩下的数据**。

- 外连接FULL OUTER JOIN就是求两个表**A和B集合的并集**。另外MySQL不支持OUTER JOIN，但是我们可以对左连接和右连接的结果做 **UNION** 操作来实现。MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。

## 13. 页和行的大小

- MySQL表具有65,535字节的最大行大小限制，即使存储引擎能够支持更大的行也是如此。
- 对于默认的16KB InnoDB页大小，最大行大小略小于8KB 。对于64KB页，最大行大小略小于16KB。如果包含可变长度列(例如：text)的InnoDB 行超过最大行大小，InnoDB选择可变长度列进行页外存储。

## 14. MySQL调优

### 14.1 排除缓存干扰

- 如果是8.0之下的版本，需要排除缓存的干扰。
- 开启缓存，那每次请求的查询语句和结果都会以key-value的形式缓存在内存中
- 缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空
- 在执行SQL的时候，记得加上SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。

### 14.2 Explain

- rows

### 14.3 覆盖索引

- 避免回表，减少树的搜索次数，显著提升查询性能
  - 在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据就必然需要根据主键值从主键索引继续查询。这个过程我们成位回表。想想回表必然是会消耗性能影响性能。那如何避免呢？
  - 使用索引覆盖，举个例子：现有User表（id(PK),name(key),sex,address,hobby...）如果在一个场景下，`select id,name,sex from user where name ='zhangsan';`这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。这样就可以有效地避免了回表再获取sex的数据。
  - **这里就是一个典型的使用覆盖索引的优化策略减少回表的情况。**

### 14.4 联合索引

- **联合索引**，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。
- **联合索引的创建原则**，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。
- **联合索引的使用**
  1. 考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。
  2. 当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。

### 14.5 最左匹配原则

- 

### 14.6 索引下推(ICP)

- 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。
- 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。
- 在MySQL 5.6之前，只能从ID1开始一个个回表，到主键索引上找出数据行，再对比字段值。
- 而MySQL 5.6 引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
- 在InnoDB中只针对二级索引有效
- **索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。**

### 14.7 唯一索引和普通索引的选择

- 唯一索引和普通索引在读取的时候效率基本差不多，普通索引差了一点点。主要是判断和特殊情况下的一次IO 
- 写入的时候，普通索引可以利用change buffer，适合写多读少，比唯一索引要快 
- 因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好，这种业务模型常见的就是账单类、日志类的系统。
- 反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价，所以，对于这种业务模式来说，change buffer反而起到了副作用。

#### 14.7.1 change buffer

- 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。
- 在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。
- 将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。
- 除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。

![MySQL_17](/Users/na/IdeaProjects/Technical summary/Image/MySQL_17.webp)

- 如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一，change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。
- 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。要判断表中是否存在这个数据，而这必须要将数据页读入内存才能判断，如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。
- 只有普通索引可以使用change buffer，change buffer用的是buffer pool里的内存，因此不能无限增大，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置，这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。

### 14.8 前缀索引

- 可以定义字符串的一部分作为索引。默认地，如果创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。
- 可以采用hash，倒序，或者删减字符串等方法建立区分度
- 把字段hash为另外一个字段存起来，每次校验hash就好了，hash的索引也不大。
- 就比如本来是www.aobing@qq,com这样的邮箱，前面的`www.`基本上是没任何区分度的，可以substring()函数截取掉前面的，然后建立索引。
- 身份证都是区域开头的，同区域的人很多，可以使用REVERSE()函数翻转一下，区分度可能就高了。

### 14.9 条件字段函数操作

- 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。
- 用一些取巧的方法，比如 select * from tradelog where id + 1 = 10000 就走不上索引，select * from tradelog where id = 9999就可以。
- 隐式类型转换也用不上索引，select * from t where id = 1，如果id是字符类型的，1是数字类型的，explain会发现走了全表扫描，根本用不上索引。因为MySQL底层会对你的比较进行转换，相当于加了 CAST( id AS signed int) 这样的一个函数，上面说过函数会导致走不上索引。
- 隐式字符编码转换也用不上索引，如果两个表的字符集不一样，一个是utf8mb4，一个是utf8，因为utf8mb4是utf8的超集，所以一旦两个字符比较，就会转换为utf8mb4再比较。转换的过程相当于加了CONVERT(id USING utf8mb4)函数，那又回到上面的问题了，用到函数就用不上索引了。

### 14.10 flush

- 

## 15. MySQL底层

### 15.1 基础框架

![MySQL_13](/Users/na/IdeaProjects/Technical summary/Image/MySQL_13.png)

- 1、连接器管理： 首先是数据库连接器，主要负责和客户端建立连接、权限获取、管理连接等，由于整个建连的过程比较复杂，所以尽量使用长连接。如果数据库发生异常后为了快速恢复，可重启系统重新建立连接
- 2、Mysql缓存：mysql请求首先看缓存数据，key为sql语句value为查询的结果，如果存在则直接返回。如果没有则直接往下走。注意：mysql缓存对于一些静态数据比较适合，对于实时性高的数据最好不要使用。
- 3、分析器： 对你执行的sql语句进行解析，首先是词法分析包括一些关键字识别，然后语法分析，查看这条语句是否符合mysql语句
- 4、优化器：通过你的语句分析，发现那些查询命中索引，还有表之间的连接顺序等
- 5、执行器：通过上面一系列的验证，使用引擎提供的接口。经过不断的执行将查询的结果存放在结果集中，通过explain可以看到执行器具体扫描了多少行。

### 15.2 **DML语句的执行流程**

- ```sql
  mysql> UPDATE T SET age = age+1 WHERE id = 1;
  ```
  
  1. 执行器先找引擎找id=1这行记录。id为主键，引擎通过索引找到记录；
  2. 执行器拿到行记录，对age+1，调用引擎写接口，更新数据；
  3. 引擎将新记录更新到内存，并将更新记录写入redo log，redo log处于prepare状态，随时可以提交事务；
  4. 执行器生成bin log写入磁盘；
  5. 执行器调用引擎提交事务接口，把redo log成成commit状态，更新完成。
  
- 注意：Mysql的redolog模块写入拆成2步走，prepare和commit，称为两阶段提交。 整个过程为1、redolog的prepare状态 2、binlog的写入 3、redolog的commit状态，保证Mysql的可靠性。
  - 对于活跃的事务，直接回滚
  - 对于redo中是Prepare状态的事务，如果binlog中已记录完成则提交，否则回滚事务

### 15.3 MySQL查询过程

![MySQL_14](/Users/na/IdeaProjects/Technical summary/Image/MySQL_14.png)

![MySQL_15](/Users/na/IdeaProjects/Technical summary/Image/MySQL_15.webp)

- 连接器：我们要进行查询，第一步就是先去链接数据库，那这个时候就是连接器跟我们对接。他负责跟客户端建立链接、获取权限、维持和管理连接。链接的时候会经过TCP握手，然后身份验证，然后我们输入用户名密码就好了。

- 查询缓存：MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。查询的时候就会拿着语句先去缓存中查询，如果能够命中就返回缓存的value，如果不命中就执行后面的阶段。

- 分析器：会先做**词法分析**，你的语句有这么多单词、空格，MySQL就需要识别每个字符串所代表的是什么，是关键字，还是表名，还是列名等等。然后就开始**语法分析**，根据词法分析的结果，语法分析会判断你sql的对错，错了会提醒你的，并且会提示你哪里错了。

- 优化器：在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 

  1.  根据搜索条件，找出所有可能使用的索引 
  2.  计算全表扫描的代价 
  3.  计算使用不同索引执行查询的代价 
  4.  对比各种执行方案的代价，找出成本最低的那一个

- 执行器：在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。查询过程中的每一张表由一个handler实例表示，实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。

- 总结下mysql整个查询流程如下: 

  1.客户端向MySQL服务器发送一条查询请求

  2.服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一级段

  3.服务器进行SQL解析、预处理、再由优化器生成对应的执行计划

  4.MySQL根据执行计划，调用存储引擎的API来执行查询

  5.将结果返回给客户端，同时缓存查询结果

## 16. 表连接和子查询

- **子查询不一定需要两个表有关联字段，而连接查询必须有字段关联（所谓的主外键关系）**
- 表关联的效率要高于子查询，因为子查询走的是笛卡尔积
- 表关联可能有多条记录，子查询只有一条记录，如果需要唯一的列，最好走子查询
- 对于数据量多的肯定是用连接查询快些，原因：因为子查询会多次遍历所有的数据（视你的子查询的层次而定），而连接查询只会遍历一次。
- 执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。

## 17. **count(\*)、count(1)、count(column)的区别**

- count(*)对行的数目进行计算,包含NULL

- count(column)对特定的列的值具有的行数进行计算,不包含NULL值。

- count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。

- 1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;

  2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;

  3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。

  - 如果表没有主键,那么count(1)比count(*)快。
  - 如果有主键,那么count(主键,联合主键)比count(*)快。
  - 如果表只有一个字段,count(*)最快。

  count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。

## 18. **主从复制**

