![排序_1](/Users/na/IdeaProjects/Technical summary/Image/排序_1.png)

| 排序法      | 平均时间 | 最差情形 | 稳定度 | 额外空间 | 备注               |
| ----------- | -------- | -------- | ------ | -------- | ------------------ |
| 冒泡        | O(n2)    | O(n2)    | 稳定   | O(1)     | n小时较好          |
| 选择        | O(n2)    | O(n2)    | 不稳定 | O(1)     | n小时较好          |
| 插入        | O(n2)    | O(n2)    | 稳定   | O(1)     | 大部分已排序时较好 |
| Shell(希尔) | O(nlogn) | O(ns)    | 不稳定 | O(1)     | s是所选分组        |
| 快速        | O(nlogn) | O(n2)    | 不稳定 | O(nlogn) | n大时较好          |
| 归并        | O(nlogn) | O(nlogn) | 稳定   | O(1)     | n大时较好          |
| 堆          | O(nlogn) | O(nlogn) | 不稳定 | O(1)     | n大时较好          |
| 桶式        | O(k+n)   | O(k+n)   | 稳定   | O(1)     | 只能排整形数组     |

## 1. 快速排序

```java
public int[] MySort (int[] arr) {
        // write code here
        quick(arr, 0, arr.length - 1);
        return arr;
    }
    
    public void quick(int[] a, int L, int R){
        if(L >= R) return;
        
        int l = L, r = R;
        int pivot = a[l];
        
        while(l < r){
            while(l < r && a[r] >= pivot){
                r--;
            }
            if(l < r){
                a[l] = a[r];
            }
            while(l < r && a[l] <= pivot){
                l++;
            }
            if(l < r){
                a[r] = a[l];
            }
            if(l >= r){
                a[l] = pivot;
            }
        }
        quick(a, L, l-1);
        quick(a, l+1, R);
    }
```

## 2. 归并排序

```java
import java.util.*;
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 将给定数组排序
     * @param arr int整型一维数组 待排序的数组
     * @return int整型一维数组
     */
    public int[] MySort (int[] arr) {
        // write code here
        return sort(arr);
    }

    private int[] sort(int []arr){
        if(arr.length==1)
            return arr;
        else{
            int mid = arr.length/2;
            int temp[]=new int[arr.length];
            int [] left=sort(Arrays.copyOfRange(arr,0,mid));
            int [] right=sort(Arrays.copyOfRange(arr,mid,arr.length));
            int i = 0;
            int j = 0;
            for(int k = 0;k<temp.length;k++){
                if(i<left.length&&j<right.length) {
                    if(left[i]<=right[j]){
                        temp[k]=left[i];
                        i++;
                    }else{
                        temp[k]=right[j];
                        j++;
                    }
                }else if(i<left.length&&j>=right.length){
                    temp[k]=left[i];
                    i++;
                }else if(i>=left.length&&j<right.length){
                    temp[k]=right[j];
                    j++;
                }
            }
            return temp;
        }
    }
}
```

