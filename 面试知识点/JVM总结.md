

# JVM面试题

[TOC]

## 1. 类加载子系统(Class Loader Subsystem) 

- 类加载子系统负责从文件系统或者网络中加载.class文件(字节码文件)，加载的类信息存放于一块叫做方法区的内存空间。

- Java类在下面两种情况下会被加载：

  1.实例化对象时，就像spring管理的bean一样，在tomcat启动时就实例化了bean，那么这个对象bean的类就加载了。

  2.通过类名调用静态变量的时候（类名.class除外）。

### 1.1 类加载的过程

  - ### 加载(Loading)

    - **类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象。**类的加载过程是由类加载器来完成，类加载器由JVM提供。我们开发人员也可以通过继承ClassLoader来实现自己的类加载器。
    - 加载的class来源
      - 从本地文件系统内加载class文件
      - 从JAR包加载class文件
      - 通过网络加载class文件
      - 把一个java源文件动态编译，并执行加载。

  - #### 验证(Verify)

    - 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
    - 主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。

  - #### 准备(prepare)

    - 为类变量分配内存并且设置该类变量的默认初始值，即零值；
    - 这里不包含用final修饰的sttic，因为final在编译的时候就会分配了，准备阶段会显式初始化；
    - 之类不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到java堆中。

  - #### 解析(Resolve)

    - 将常量池内的符号引用转换为直接引用的过程。
    - 事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行
    - 符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
    - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

  - ### 初始化(Initialize)

    - 初始化阶段就是执行类构造器方法clinit（）的过程。
    - **java类中对类变量进行初始化的两种方式：** **在定义时初始化**和**在静态初始化块内初始化**。 `我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法`
    - 构造器方法中指令按语句在源文件中出现的顺序执行
    - clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的init()）
    - 若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕
    - **接口与类不同的是，执行接口的＜clinit＞方法不需要先执行父接口的＜clinit＞方法。** **只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞方法。**
    - **虚拟机会保证一个类的< clinit>方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的< clinit>方法，其他线程都需要阻塞等待，直到活动线程执行< clinit>方法完毕。**

### 1.2 类加载器分类

 - 分别为**引导类加载器（BootStrap ClassLoader）**和**自定义类加载器（User-Defined ClassLoader）**

  - 启动类加载器（引导类加载器，BootStrap ClassLoader）
    - 这个类加载使用**C/C++语言实现的**，嵌套在JVM内部
    - 它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
    - 并不继承自java.lang.ClassLoader,没有父加载器
    - 加载拓展类和应用程序类加载器，并指定为他们的父加载器
    - 处于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类
  - 拓展类加载器（Extension ClassLoader）
  
    - java语言编写 ，由sun.misc.Launcher$ExtClassLoader实现。
    - 派生于ClassLoader类
    - 父类加载器为启动类加载器
    - 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。**如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载**
  - 应用程序类加载器（系统类加载器，AppClassLoader）
  
    - java语言编写， 由sun.misc.Launcher$AppClassLoader实现。
    - 派生于ClassLoader类
    - 父类加载器为拓展类加载器
    - 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库
    - **该类加载器是程序中默认的类加载器**，一般来说，java应用的类都是由它来完成加载
    - 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器

### 1.3 类加载机制
- **全盘负责**：当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也由该类加载器负责载入，除非显示使用另一个类加载器来载入。

- **双亲委派**：先让父加载器试图加载该Class，只有在父加载器无法加载时该类加载器才会尝试从自己的类路径中加载该类。避免类的重复加载，保护程序安全，防止核心API被随意篡改。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。

- 双亲委派的好处
  - 虚拟机只有在两个类的类名相同且加载该类的加载器均相同的情况下才判定这是一个类。若不采用双亲委派机制，同一个类有可能被多个类加载器加载，这样该类会被识别为两个不同的类，相互赋值时会有问题。
- 双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。
  - 其次是考虑到安全因素。假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。
  
- **缓存机制**：缓存机制会将已经加载的class缓存起来，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存中不存在该Class时，系统才会读取该类的二进制数据，并将其转换为Class对象，存入缓存中。**这就是为什么更改了class后，需要重启JVM才生效的原因。**

- 沙箱安全机制

  - **自定义String类，由于双亲委派机制加载这个自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制**。
  - 自定义类加载器加载自定义的String类也是不行的，不能自己写以"java."开头的类，其要么不能加载进内存，要么即使你用自定义的类加载器去强行加载，也会收到一个SecurityException。
  

### 1.4 类初始化时机

- 当虚拟机启动时，初始化用户指定的主类；

- 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类；

- 当遇到调用静态方法或者使用静态变量，初始化静态变量或方法所在的类；

- 子类初始化过程会触发父类初始化；

- 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口初始化；

- 使用反射API对某个类进行反射调用时，初始化这个类；

- Class.forName()会触发类的初始化

- **对于一个使用final定义的常量，如果在编译时就已经确定了值，在引用时不会触发初始化，因为在编译的时候就已经确定下来，就是“宏变量”。如果在编译时无法确定，在初次使用才会导致初始化。**

- ##### ClassLoader只会对类进行加载，不会进行初始化

### 1.5 判断是同一个类

- **每个类在JVM中使用全限定类名（包名+类名）与类加载器联合为唯一的ID，所以如果同一个类使用不同的类加载器，可以被加载到虚拟机，但彼此不兼容。一个类，由不同的类加载器实例加载的话，会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同Class实例。**

### 1.6 自定义类加载

- 除了根类加载器，所有类加载器都是ClassLoader的子类。所以我们可以通过继承ClassLoader来实现自己的类加载器。
- ClassLoader类有两个关键的方法：
  1. protected Class **loadClass(String name, boolean resolve)**：name为类名，resove如果为true，在加载时解析该类。
  2. protected Class **findClass(String name)** ：根据指定类名来查找类。
- **loadClass加载方法流程：**
  1. **判断此类是否已经加载；**
  2. **如果父加载器不为null，则使用父加载器进行加载；** **反之，使用根加载器进行加载；**
  3. **如果前面都没加载成功，则使用findClass方法进行加载。**
- 推荐重写findClass方法，而不是重写loadClass方法，因为loadClass方法内部会调用findClass方法：

```java
public class Hello {
   public void test(String str){
       System.out.println(str);
   }
}

public class MyClassloader extends ClassLoader {

    /**
     * 读取文件内容
     *
     * @param fileName 文件名
     * @return
     */
    private byte[] getBytes(String fileName) throws IOException {
        File file = new File(fileName);
        long len = file.length();
        byte[] raw = new byte[(int) len];
        try (FileInputStream fin = new FileInputStream(file)) {
            //一次性读取Class文件的全部二进制数据
            int read = fin.read(raw);
            if (read != len) {
                throw new IOException("无法读取全部文件");
            }
            return raw;
        }
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class clazz = null;
        //将包路径的(.)替换为斜线(/)
        String fileStub = name.replace(".", "/");
        String classFileName = fileStub + ".class";
        File classFile = new File(classFileName);

        //如果Class文件存在，系统负责将该文件转换为Class对象
        if (classFile.exists()) {
            try {
                //将Class文件的二进制数据读入数组
                byte[] raw = getBytes(classFileName);
                //调用ClassLoader的defineClass方法将二进制数据转换为Class对象
                clazz = defineClass(name, raw, 0, raw.length);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        //如果clazz为null,表明加载失败，抛出异常
        if (null == clazz) {
            throw new ClassNotFoundException(name);
        }
        return clazz;
    }

    public static void main(String[] args) throws Exception {
        String classPath = "loader.Hello";
        MyClassloader myClassloader = new MyClassloader();
        Class<?> aClass = myClassloader.loadClass(classPath);
        Method main = aClass.getMethod("test", String.class);
        System.out.println(main);
        main.invoke(aClass.newInstance(), "Hello World");
    }
}
```

### 1.7 打破双亲委派机制

- 双亲委派模型的第一次“被破坏”是重写自定义加载器的loadClass(),jdk不推荐。一般都只是重写findClass()，这样可以保持双亲委派机制.而loadClass方法加载规则由自己定义，就可以随心所欲的加载类了。
- 线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。

## 2. 程序计数器(Program Counter Register)：线程私有

- PC寄存器是当前线程所执行的字节码的行号指示器，用来存储指向下一条指令的地址。
- 是线程私有的，生命周期与线程的生命周期保持一致。
- 程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）。
- 没有OOM，也不会出现GC垃圾回收。
- 使用PC寄存器存储字节码指令地址有什么用呢？/ 为什么使用PC寄存器记录当前线程的执行地址呢？
  - 因为CPU需要不停的切换各个线程，在切换回该线程时，CPU需要知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
- PC寄存器为什么会设定为线程私有？
  - 多线程在一个特定的时间段内会执行其中某一个线程的方法，CPU会不停地在不同的任务中切换，这样必然会导致经常中断或恢复，**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

## 3. 虚拟机栈(JVM Stack)：线程私有

- 是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
- 如果采用固定大小的Java虚拟机栈，如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 **StackOverFlowError**异常；如果java虚拟机栈可以动态拓展，尝试扩展时无法得到足够的内存或创建新线程时没有足够的内存去创建对应的虚拟机栈，将会抛出一个 **OutOfMemoryError异常**。
- 使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）
- 栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁。
  - 局部变量表（Local Variables）：**定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。
    - **最基本的存储单元是Slot(变量槽)**，**32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。**
    - 如果当前帧是由构造方法或者实例方法创建的，那么**该对象引用this将会存放在index为0的slot处**
    - 局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。
  - 操作数栈（Operand Stack）：**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。**
    - 在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）
    - 32bit的类型占用一个栈单位深度，64bit的类型占用两个栈深度单位。
    - **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令。
  - 动态链接（Dynamic Linking）：每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。
    - 在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**
    - 当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
    - 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。
    - 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法：**静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法**
  - 方法返回地址（Return Address）：存放调用该方法的PC寄存器的值。
    - 一个方法的结束，有两种方式：正常执行完成；出现未处理的异常，非正常退出
    - 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。**而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

## 4. 本地方法栈：线程私有

- 本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务
-  HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

## 5. 堆(Heap)：线程共享

- 是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。
- -Xms 用于表示堆的起始内存，-Xmx 用于设置堆的最大内存
- JDK 7以前： 新生区+养老区+永久区；JDK 8以后： 新生区+养老区+元空间
- 默认-XX：NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
- Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1，通过选项 -XX:SurvivorRatio 调整空间比例
- 对象晋升老年代的年龄阈值，默认是15次。可以设置参数：-XX:MaxTenuringThreshold=进行设置。
- 新生代：是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。
  - Eden区：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
  - Survivor0区(from区)：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
  - Survivor1区(to区)：保留了一次 MinorGC 过程中的幸存者。
- 老年代：主要存放应用程序中生命周期长的内存对象。
  - 大对象直接进入老年代。比如很长的字符串，或者很大的数组等。
  - 长期存活的对象进入老年代。在堆中分配内存的对象，其内存布局的对象头中（Header）包含了 GC 分代年龄标记信息。如果对象在 eden 区出生，那么它的 GC 分代年龄会初始值为 1，每熬过一次 Minor GC 而不被回收，这个值就会增加 1 岁。当它的年龄到达一定的数值时（jdk1.7 默认是 15 岁），就会晋升到老年代中。
  - 动态对象年龄判定。当 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄。
- MinorGC：采用复制算法对年轻代进行GC，会引发STW
  - eden 快满的触发因素有两个，一个是为对象分配内存不够，一个是为 TLAB 分配内存不够。
  - 首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）
  - 然后，清空 Eden 和 ServicorFrom 中的对象
  - 最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。
- Major GC：采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。
  - 会引发STW
  - 在进行 MajorGC 前一般都先进行了一次 MinorGC
- Full GC：回收整个堆，包括年轻代、老年代，如果有永久代的话还包括永久代。
  - 在要进行 young gc 的时候，根据之前统计数据发现年轻代平均晋升大小比现在老年代剩余空间要大，那就会触发 full gc。
  - 永久代或元空间满了也会触发 full gc。
  - 老年代空间不足，大对象直接在老年代申请分配，如果此时老年代空间不足则会触发 full gc。
  - 空间分配担保：在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC。
  - 执行 System.gc()、jmap -dump 等命令会触发 full gc。
- mixed gc：这个是 G1 收集器特有的，指的是收集整个年轻代和部分老年代的 GC。
- TLAB（Thread Local Allocation Buffer）：JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内，使用TLAB可以避免一系列的非线程安全问题和对象分配时的竞争。这个区域只允许这一个线程申请分配对象，允许所有线程访问这块内存区域。
- 堆是分配对象的唯一选择么（不是）
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

### 5.1 新生代

- **为什么会有新生代？**

  如果不分代，所有对象全部在一个区域，每次GC都需要对全堆进行扫描，存在效率问题。分代后，可分别控制回收频率，并采用不同的回收算法，确保GC性能全局最优。

- **为什么新生代会采用复制算法？**

  新生代的对象朝生夕死，大约90%的新建对象可以被很快回收，复制算法成本低，同时还能保证空间没有碎片。虽然标记整理算法也可以保证没有碎片，但是由于新生代要清理的对象数量很大，将存活的对象整理到待清理对象之前，需要大量的移动操作，时间复杂度比复制算法高。

- **为什么新生代需要两个Survivor区？**

  为了节省空间考虑，如果采用传统的复制算法，只有一个Survivor区，则Survivor区大小需要等于Eden区大小，此时空间消耗是8 * 2，而两块Survivor可以保持新对象始终在Eden区创建，存活对象在Survivor之间转移即可，空间消耗是8+1+1，明显后者的空间利用率更高。

- **新生代的实际可用空间是多少？**

  YGC后，总有一块Survivor区是空闲的，因此新生代的可用内存空间是90%。在YGC的log中或者通过 jmap -heap pid 命令查看新生代的空间时，如果发现capacity只有90%，不要觉得奇怪。

- **Eden区是如何加速内存分配的？**

  HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread Local Allocation Buffers）。

  由于Eden区是连续的，因此bump-the-pointer在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而加快内存分配速度。

  TLAB技术是对于多线程而言的，在Eden中为每个线程分配一块区域，减少内存分配时的锁冲突，加快内存分配速度，提升吞吐量。

## 6. 方法区(Method Area)：线程共享

- 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
- 在jdk7及以前，习惯上把方法区称为永久代。jdk8开始，使用元空间取代了永久代。元空间不再虚拟机设置的内存中，而是使用本地内存。
- 运行时常量池：常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
- 方法区的变化：
  - jdk1.6及之前：有永久代（permanent generation） ，静态变量存放在永久代上
  - jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中
  - jdk1.8及之后： 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆

![方法区_7](/Users/na/IdeaProjects/Technical summary/Image/方法区_7.webp)

![方法区_8](/Users/na/IdeaProjects/Technical summary/Image/方法区_8.webp)

![方法区_9](/Users/na/IdeaProjects/Technical summary/Image/方法区_9.webp)

- 永久代为什么要被元空间替换：为永久代设置空间大小是很难确定的。 在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。在元空间中，由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
- StringTable 为什么要调整：因为永久代的回收效率很低，在full gc的时候才会触发。而full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存.
- 方法区的垃圾回收：常量池中废弃的常量和不再使用的类型
  - 常量池之中主要存放的两大类常量：字面量和符号引用。只要常量池中的常量没有被任何地方引用，就可以被回收。
  - 判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
    - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
    - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
    - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 7. 创建对象

- 创建对象的方式:
  - new
    - 最常见的方式
    - 变形1 ： Xxx的静态方法
    - 变形2 ： XxBuilder/XxoxFactory的静态方法
  - Class的newInstance（）：反射的方式，只能调用空参的构造器，权限必须是public
  - Constructor的newInstance（Xxx）：反射的方式，可以调用空参、带参的构造器，权限没有要求
  - 使用clone（） ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）
  - 使用反序列化：从文件中、从网络中获取一个对象的二进制流
  - 第三方库Objenesis
  
- 创建对象的步骤:
  - 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。
  - 为对象分配内存
    1. 指针碰撞： 假设 Java 堆内存规整，利用一个指针将内存分为两部分，分配内存就是把指针向空闲方向挪动一段与对象大小相等的距离。
    2. 空闲列表：如果 Java 堆内存不规整，虚拟机维护一个列表记录可用内存，分配时从列表中找到一块足够的空间划分给对象并更新列表。
  - 处理并发安全问题：在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用 了两种方式解决并发问题：
    - CAS （ Compare And Swap ）失败重试、区域加锁：保证指针更新操作的原子性；
    - TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer） 虚拟机是否使用TLAB，可以通过一XX：+/一UseTLAB参数来 设定。
  - 初始化分配到的空间，所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用
  - 设置对象的对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。
  - 执行init方法进行初始化，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。
  
- 对象的内存布局：
  
  - 对象头（Header）包含两部分
  
    - 运行时元数据
      - 哈希值（ HashCode ）
      - GC分代年龄
      - 锁状态标志
      - 线程持有的锁
      - 偏向线程ID
      - 偏向时间戳
    - 类型指针：指向类元数据的InstanceKlass，确定该对象所属的类型
    - 说明：如果是数组，还需记录数组的长度
  - 实例数据（Instance Data）：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） 
  - 对齐填充：仅起占位符作用。虚拟机的内存管理系统要求任何对象的大小必须是 8B 的倍数，如果没有对齐需要对齐填充补全。
  
-  对象的访问定位
  
  - 直接指针(HotSpot采用)
  
  ![创建对象的方式_4](/Users/na/IdeaProjects/Technical summary/Image/创建对象的方式_4.webp)
  
  - 句柄访问
  
  ![创建对象的方式_3](/Users/na/IdeaProjects/Technical summary/Image/创建对象的方式_3.webp)
  
  ![创建对象的方式_5](/Users/na/IdeaProjects/Technical summary/Image/创建对象的方式_5.png)

## 8.直接内存

- 不是虚拟机运行时数据区的一部分，是Java堆外的、直接向系统申请的内存区间
- 直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值一Xmx参数值一致

## 9. 执行引擎

- 将字节码指令解释/编译为对应平台上的本地机器指令
- 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码
- **解释器**：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行(将字节码文件逐行转为机器码执行)，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
  - 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。
    - Interpreter模块：实现了解释器的核心功能
    - Code模块：用于管理HotSpot VM在运行时生成的本地机器指令
- **JIT （Just In Time Compiler）编译器（即时编译器）**：就是虚拟机将将字节码文件直接编译成机器码。
- 当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
- 热点探测：HotSpot VM所采用的热点探测方式是基于计数器的热点探测
  - 方法调用计数器（Invocation Counter）：统计方法的调用次数
    - 它的默认阈值在Client 模式 下是1500 次，在Server 模式下是10000 次。超过这个阈值，就会触发JIT编译。
    - 这个阈值可以通过虚拟机参数一XX ：CompileThreshold来人为设定。
  - 回边计数器（BackEdge Counter）：统计循环体执行的循环次数
  - 当一个方法被调用时， 会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。
  - 热度的衰减（Counter Decay）：当超过一定的时间限度， 如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半。
- JIT分类：
  - -client： 指定Java虚拟机运行在Client模式下，并使用C1编译器；
    - C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。
    - C1编译器上主要有方法内联，去虚拟化、冗余消除。
      - 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
      - 去虚拟化：对唯一的实现类进行内联
      - 冗余消除：在运行期间把一些不会执行的代码折叠掉
  - -server： 指定Java虚拟机运行在Server模式下，并使用C2编译器。
    - C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。
    - C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2.上有如下几种优化：（server模式下才会有这些优化，64位系统默认就是server模式）
      - 标量替换：用标量值代替聚合对象的属性值
      - 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
      - 同步消除：清除同步操作，通常指synchronized，如StringBuffer 实现多个append方法
  - Java7版本之后，一旦开发人员在程序中显式指定命令“一server"时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。

## 10. 字符串常量池

- String Pool 是一个固定大小的Hashtable，字符串常量池中是不会存储相同内容的字符串。
- Java 6及以前，字符串常量池存放在永久代。Java 7将字符串常量池的位置调整到Java堆内。
- 调整的原因：永久代permSize默认比较小; 永久代的垃圾回收频率低;
- String的intern（）的使用

  - jdk1.6中，将这个字符串对象尝试放入字符串常量池。
    - ➢如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址
    - ➢如果没有，会把此对象复制一份，放入字符串常量池，并返回字符串常量池中的对象地址
  - Jdk1.7起，将这个字符串对象尝试放入字符串常量池。
    - ➢如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址
    - ➢如果没有，则会把对象的引用地址复制一份，放入字符串常量池，并返回字符串常量池中的引用地址

## 11. 如何释放堆外内存？

- JDK中使用DirectByteBuffer对象来表示堆外内存，每个DirectByteBuffer对象在初始化时，都会创建一个对应的Cleaner对象，这个Cleaner对象会在合适的时候执行unsafe.freeMemory(address)，从而回收这块堆外内存。

![堆_8](/Users/na/IdeaProjects/Technical summary/Image/堆_8.jpg)

- 其中first是Cleaner类的静态变量，Cleaner对象在初始化时会被添加到Clener链表中，和first形成引用关系，Cleaner继承虚引用，ReferenceQueue是用来保存需要回收的Cleaner对象。

- 如果该DirectByteBuffer对象在一次GC中被回收了，此时，只有Cleaner对象唯一保存了堆外内存的数据（开始地址、大小和容量），在下一次FullGC时，把该Cleaner对象放入到ReferenceQueue中，并触发clean方法。

  　　Cleaner对象的clean方法主要有两个作用：

    　　1、把自身从Clener链表删除，从而在下次GC时能够被回收

    　　2、释放堆外内存

## 12. JVM频繁FGC怎么办？

- **清楚从程序角度，有哪些原因导致FGC？** 

  - 大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。
  - 内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.
  - 程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）
  - 程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.
  - 代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。
  - JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。

- **清楚排查问题时能使用哪些工具**，**监控GC的状态**

  - JDK的命令行工具

    1、jps（JVM Process Status Tools）：虚拟机进程状况工具

    ```
    jps -l
    ```

    2、jinfo（Configuration Info for java）：Java配置信息工具

    ```
    jinfo [option] pid　　
    ```

    3、**jmap(Memory Map for java)：**java内存映像工具，查看堆内存中的存活对象，并按空间排序。用于生成堆内存快照，即dump文件

    ```
    jmap -dump:live,format=b,file=xxxx.hprof pid // 堆内存快照
    jmap -histo:live pid // 直接查看堆内存存活的对象。
    jmap -heap pid // JVM内存的「实际配置」
    ```

    4、jstat（JVM Statistics Monitoring Tool)：虚拟机统计信息监视工具，查看堆内存各区域的使用率以及GC情况

    ```
    jstat -gc ``2764` `250` `20` `# -gc监视java堆状况 每``250``毫秒查询一次进程``2764``垃圾收集状态，共查询``20``次``jstat -gcutil ``2754` `#监视java堆内存使用状况　
    top -p ``12309` `-H  #-p用于指定进程，-H用于获取每个线程的信息　　
    ```

    5、jhat(JVM Heap Analysis Tool)：虚拟机dump文件分析工具

    ```
    jhat eclipse.bin
    ```

    屏幕显示“server is ready”，用户在浏览器中键入http://localhost:7000/就可以看到分析结果

    6、jstack（Stack Trace for java）：java虚拟机自带的堆栈跟踪工具

    ```
    jstack -l ``3500` `　
    ```

    jstack命令查看线程堆栈信息时可能会看到的线程的几种状态：

    ```
    NEW,未启动的。不会出现在Dump中。``RUNNABLE,在虚拟机内执行的。``BLOCKED,受阻塞并等待监视器锁。``WATING,无限期等待另一个线程执行特定操作。``TIMED_WATING,有时限的等待另一个线程的特定操作。``TERMINATED,已退出的。
    ```

    jstack用于生成java虚拟机当前时刻的线程快照。

    线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合。

    生成线程快照的主要目的是定位线程出现长时间停顿的原因。

    线程长时间停顿的主要原因：等待外部资源（数据库连接、网络资源、设备资源）、死循环、锁等待（活锁和死锁）。

    线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源

  - 二、JDK的可视化工具，**分析dump文件**

    JConsole：Java监视与管理控制台

    **Mat(Eclipse专门的静态内存分析工具)推荐使用**

    JVisualVM：通过JVisualVM工具导入dump出来的堆内存文件，同样可以看到各个对象所占空间

  ![jvm性能分析工具](/Users/na/IdeaProjects/Technical summary/Image/jvm性能分析工具.png)

- **排查指南**

  - 查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）
  
  - 了解该时间点之前有没有程序上线、基础组件升级等情况。
  
  - 了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。
  
  - 再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。
  
  - 针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。
  
  - 通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。
  
    