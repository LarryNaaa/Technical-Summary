# 智力题

[TOC]

https://www.jianshu.com/p/0aef53a3caf6

## 1. 有64匹马，一共有8个赛道，想要找出最快的4匹马，要比赛最少多少轮才可以?

- 第一步：全部马分为8组，每组8匹，每组各跑一次，然后淘汰掉每组的后四名，如下图（需要比赛8场）

![智力题_1](/Users/na/IdeaProjects/Technical summary/Image/智力题_1.png)

- 第二步：取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马，如下图（需要比赛1场）

![智力题_2](/Users/na/IdeaProjects/Technical summary/Image/智力题_2.png)

- 这个时候总冠军已经诞生，它就是A1，蓝色区域（它不需要比赛了），而其他可能跑得最快的三匹马只可能是下图中的黄色区域了（A2,A3,A4,B1,B2,B3,C1,C2,D1，共9匹马）

![智力题_3](/Users/na/IdeaProjects/Technical summary/Image/智力题_3.png)

- 第三步：只要从上面的9匹马中找出跑得最快的三匹马就可以了，但是现在只要8个跑道，怎么办？那就随机选出8匹马进行一次比赛吧（需要比赛一场）
- 第四步：上面比赛完，选出了前三名，但是9匹马中还有一匹马没跑呢，它可能是一个潜力股啊，那就和前三名比一比吧，这四匹马比一场，选出前三名。最后加上总冠军，跑得最快的四匹马诞生了！！！（需要一场比赛）
- 最后：一共需要11场

## 2. 9个人，一枚色子，选出两人，怎么比较公平？



## 3. 输入每个课程之间的关系，比如1->2，表示学习课程2需要先学习课程1，每轮学习课程 项目不限，问最快几轮学习完？

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 拓扑排序，入度数组
        int[] degree = new int[numCourses];

        for(int[] prerequisity : prerequisites){
            degree[prerequisity[0]]++;
        }

        Queue<Integer> q = new LinkedList<>();
        for(int i = 0; i < numCourses; i++){
            if(degree[i] == 0){
                q.offer(i);
            }
        }

        int count = 0;

        while(!q.isEmpty()){
            int size = q.size();

            for(int i = 0; i < size; i++){
                int curr = q.poll();

                for(int[] prerequisity : prerequisites){
                    if(prerequisity[1] == curr){
                        degree[prerequisity[0]]--;
                        if(degree[prerequisity[0]] == 0){
                            q.offer(prerequisity[0]);
                        }
                    }
                }
            }
            count++;
        }
        return count;
    }
}
```

## 4. 烧一根不均匀的绳子,从头烧到尾是要1个小时.现在有若干条材质相同的绳子 问如何用烧绳的方法来计时一个小时15分钟.

- 答案：把第一根绳子两头同时点燃,同时把第二根绳子点燃一头,当第一根绳子烧完时,时间为半个小时,这时把第二根绳子的另一头也点燃,开始计时,当第二根绳子烧完时,停止计时,那么这段时间就是15分钟。也就是说，只需要3根绳子就可以计时一个小时15分钟。
- 追问：
  1根两头烧，一根一头烧。当两头烧的烧完的时候就是半小时，此时立刻点燃那根一头烧的另一头，烧完就是45分钟。这根也烧完的时候立刻点燃第三根的两头，烧完就是75分钟。

## 5. 三门问题



## 6. 一硬币，一面向上概率0.7，一面0.3，如何公平？

连续抛两次硬币，正反面的出现有四种情况，概率依次为：

1. 两次均为正面：p * p
2. 第一次正面，第二次反面：p * (1 - p)
3. 第一次反面，第二次正面：(1 - p) * p
4. 两次均为反面：(1 - p) * (1 - p)

这不，中间两种情况的概率是完全一样的。于是问题的解法就是连续抛两次硬币，如果两次得到的相同则重新抛两次；否则根据第一次（或第二次）的正面反面情况，就可以得到两个概率相等的事件。

抛两次，正反A胜，反正B胜。

## 7. 两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率

每一轮抛硬币，A先抛赢得概率是1/2，B后抛赢得概率是（1/2）*（1/2）= 1/4。那么每一轮A赢得概率都是B赢得概率的2倍，总概率为1,所以A赢的概率是2/3。

## 8. 海盗分金币

### 8.1 在加勒比海上，有五个海盗，共同抢到了100枚金币， 每一个人按顺序依次提出自己的分配方案，如果提出的方案没有获得**半数或半数以上**的人的同意，则这个提出方案的人就被扔到海里喂鲨鱼，那么第一个提出方案的人要怎么做，才能使自己的利益最大化？

假使前三个人都因为分配金币的方式不合理而被扔下大海，此时还剩下两个人，也就是4号和5号，那么问题就简单了：

- 4号和5号分金币的情况：
      4号提出方案，自己一定会同意的，并且只要自己同意，这个方案就已经获得了半数的支持，就可以被实施
      因此，无论5号是否同意4号提出的方案，都不会对最终的结果造成影响，因此，4号一定会要100枚金币，以使自己的利益最大化，结果就变成了这样：
          4号        5号
          100        0
      
  现在我们多添加一个人，
- 3号，4号和5号分金币的情况：
      3号要使自己的提议获得半数的支持就必须再拉拢一个人，拉拢4号显然是不合适的，4号一定不会同意，4号知道，只要搞死了3号，剩下的100枚金币都是自己的。（就像上面4号和5号分金币的情况）拉拢5号是合适的，因为5号之前得不到金币，现在只要3号给5号一个金币就能够获得5号的支持，因为5号也知道，如果3号死亡，自己一定一枚金币都得不到。

情况就变成了这样：

​      3号        4号       5号
​      99           0          1

现在我们再多添加一个人：

- 2号，3号，4号和5号分金币的情况：
      2号要使自己的提议获得半数的支持也必须再拉拢一个人，拉拢3号显示是不合适的，3号一定不会同意，3号知道，只要搞死了2号，有99枚金币都是自己的（就像上面3号，4号和5号分金币的情况）， 拉拢5号貌似是可以的，他已经有一个金币了，要让他支持自己只要再多给他一个金币就可以了，拉拢4号也是可以的，4号现在没有金币，只要给他一个就可以让他自持自己的提案，综上所述，要让自己利益最大化，就需要拉拢4号，因为只要给4号一个金币即可：
      情况就变成了这样：
          2号        3号        4号        5号
          99           0            1        0
      
  最后我们再多添加一个人这道题目的答案就出来了：
- 1号，2号，3号，4号和5号分金币的情况：

1号要使自己的提议获得半数的支持必须拉拢两个人，拉拢2号显示是不合适的，2号一定不会同意，2号知道，只要搞死了1号，有99枚金币都是自己的，（就像上面2号，3号，4号和5号分金币的情况）， 拉拢4号貌似是可以的，他已经有一个金币了，要让他支持自己需要再给他一个金币才可以，这样做并不能让自己的利益最大化， 拉拢3号是可以的，3号现在没有金币，只要给他一个就可以让他自持自己的提案， 5号跟3号情况一至，同样没有金币，只要给他一个就可以了，综上所述，要让自己利益最大化，就需要拉拢3号跟5号，因为拉拢他们两个只需要各自给一个金币即可：
情况就变成了这样：
        1号        2号        3号        4号        5号
        98           0            1            0           1

### 8.2 超过半数同意方案才被通过,否则他将被扔入大海喂鲨鱼

##### 两个海盗--毫无悬念

很显然,当只有两个海盗的时候,一号一定会死,因为首先只要第一个海盗死了,剩下的一个便能获得全部的金币,根据==贪得无厌==的原则,二号也不会投同意票,即使一号选择
 ==(0,100)(即一号获得0个金币,二号获得100个)==,但是根据==心狠手辣==的原则,二号还是不会投同意票,所以此时无论如何也不会有半数以上的同意票,此时的一号表示:为什么我这么惨啊!

> 结果 (0, 100)

##### 三个海盗--无奈的选择

当存在三个海盗的时候,原来的两个海盗时的一号变成了二号,此时二号知道了,如果一号被投死,那么毫无悬念的,他没有任何活路,根据==贪生怕死==的原则,他会无论如何保全自己,换句话说,他无论如何都会同意此时一号的题意,那么此时聪明的一号知道他们的想法之后就开心的不行了,因为无论自己提什么条件自己都会得到半数以上的投票.那根据==贪得无厌==的原则,结果显而易见.

> 结果 (100, 0, 0)

##### 四个海盗--稍稍讨好就可以

四个海盗时,此时的一号明白了此时的二号是讨好不了的.因为自己死了二号就一定能得到全部100枚金币,所以干脆不讨好,给他0枚金币吧.而此时除了自己的票还差两票,那么只要讨好三号和四号获得这两票就好,三号和四号相当容易讨好的,因为一号死了,他们就只能得到空气(三个海盗的结果为(100, 0, 0)),那么给他一块金币就好啦.当然一号不能不给三号四号金币,因为海盗都是==心狠手辣==的,==[如果不管你死不死我都是0块金币,那我干脆要你死算了]==.

> 结果 (98, 0, 1, 1)

##### 五个海盗--照本宣科

相同的原理,现在的一号需要2票就能保证存活,首先二号是不考虑了给金币了,不管给多少都反对的,三号给一个金币就行,然后还差一票,只要给==四号或五号==其中一个两枚金币,另一个不给,就可以.但这里要注意一下,此时的分歧已经产生,后面的推广推理中会用到.

> 结果: (97, 0, 1, 2, 0)或(97, 0, 1, 0, 2)

到这里我们关于五个海盗分金币的问题就得到了完美的解决,看似最惨的一号海盗得到了最多的获利,令人侧目,可惜人不都是完全理性的,有时甚至愚蠢之极,但这或许就是社会令人难以着迷也最令人害怕的地方的地方.

------

#### 更多的推广和规律

五个海盗的故事结束了,现在来了六个海盗,

我们继续可以按照之前的思路分析现在的情况,一号需要3票,二号不能讨好,三号给一枚,四号五号六号呢,这就出现的不是很好理解的情况,我先说明最后的结果是:

> (97, 0, 1, 0, 1, 1)

为什么呢,我们可以从上面的推理发现我们其实一直没用到5.==疑心多虑==的原则,而现在就用到了,因为在五个海盗的时候有两种分法,四号和五号都可能分到2枚金币,也都可能分到0枚,他们不敢保证自己在这个人死后下一个人提方案时会给自己2枚还是0枚,那现在只要一号给他们一枚金币,他们就一定会投同意票
 ==(不信任彼此，尽量确保自身利益不寄希望与别人给自己更大利益)==.

所以这种分法是对一号收益最多的,否则他还要要花两枚金币去收买四号,一枚金币收买五六号中的一个 ==((96, 0, 1, 2, 0, 1)或(96, 0, 1, 2, 1, 0))==,这样不是最优的.

同样的思路推广下去我们会发现这样的规律:

> 当 n为偶数时只要给二号到n号0,1,0,1...0,1,0,1,1
>  当 n 为奇数时给1,x,1,x....x,x.(任意一个x是二其余都是0)

上述情况的答案都是m-n/2

## 9.  坐标系中有一个球桌，四个角坐标：(0,0), (0,4), (2,4), (2,0)，一颗球在(1,1)，请问从哪些角度可以射入洞内（可无限次碰撞）？

一般想法是将球镜像对称，但这道题是把洞镜像对称，将这个桌面在这个平面无限延展，可类比成无限张球桌紧密放置，那么每一个和球洞的连线都是合法路径

## 10. 54张扑克牌，平均分成3份，大小王在一份的概率

首先大王一定会在某一份中，然后要计算这一份中还要包含小王的概率。去掉大王还剩53张牌，这一份还可以分17张牌，那么每次分到小王的概率是1/53,所以总概率是17/53。

![智力题_4](/Users/na/IdeaProjects/Technical summary/Image/智力题_4.webp)

# 场景题

## 1. 让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。

传入参数有总钱数，分的份数，随机分还是等分。先判断钱数能不能分那么多份，这个直接用总钱数>=0.01*份数判断就可以了。然后根据分发策略，选择随机还是等分，随机的话就给 1到总钱数-（总份数-1）*0.01 的随机数（总钱数以分为单位），等分的话直接除判断能不能除开，有余数就将余数加到最后一份里面。

## 2. 需求：谁关注了我，我关注了谁，谁与我互相关注。表该如何设计，索引怎么建。查询语句怎么写

粉丝关注表使用四列，主键id，userId，fansId，是否互相关注。用两行数据来保存互相的关注关系，这样查询起来更方便，用空间换时间。

主键有主键索引，剩下的字段不适合建索引，因为字段重复太多。

## 3. 分布式多个机器生成id，如何保证不重复?

1.snowflake方案：

snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。

优点：

1.毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。

2.不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。

3.可以根据自身业务特性分配bit位，非常灵活。

缺点：

强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。

2.用Redis生成ID：

因为Redis是单线程的，也可以用来生成全局唯一ID。可以用Redis的原子操作INCR和INCRBY来实现。

此外，可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis，可以初始化每台Redis的值分别是1,2,3,4,5，步长都是5，各Redis生成的ID如下：

A：1,6,11,16

B：2,7,12,17

C：3,8,13,18

D：4,9,14,19

E：5,10,15,20

这种方式是负载到哪台机器提前定好，未来很难做修改。3~5台服务器基本能够满足需求，都可以获得不同的ID，但步长和初始值一定需要事先确定，使用Redis集群也可以解决单点故障问题。

另外，比较适合使用Redis来生成每天从0开始的流水号，如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。

优点：

1）不依赖于数据库，灵活方便，且性能优于数据库。

2）数字ID天然排序，对分页或需要排序的结果很有帮助。

缺点：

1）如果系统中没有Redis，需要引入新的组件，增加系统复杂度。

2）需要编码和配置的工作量较大。

## 4. LRU算法怎么设计

使用LinkedHashMap可以实现，相对于HashMap,增加了双向链表，用于记录节点之间的先后顺序。LinkedHashMap的构造函数提供了一个参数accessOrder，这个参数可以指定链表是按照插入顺序排队还是按照访问顺序排队。参数为true时，就是按照访问顺序（插入，查询）排队，每次访问后这个节点就会被放到链表头，而长时间不被访问的节点逐渐就到了列表尾部，当需要淘汰时，就将链表尾部的节点抛弃。

## 5. 数据库连接池怎么设计

需要考虑的问题：

1. 限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源。
2. 当客户请求连接，而连接池中所有连接都已被占用时，该如何处理呢？一种方式是让客户一直等待，直到有空闲连接，另一种方式是为客户分配一个新的临时连接。
3. 当客户不再使用连接，需要把连接重新放回连接池。
4. 连接池中允许处于空闲状态的连接的最大项目。假定允许的最长空闲时间为十分钟，并且允许空闲状态的连接最大数目为5，

那么当连接池中有n个(n>5)连接处于空闲状态的时间超过十分钟时，就应该把n-5个连接关闭，并且从连接池中删除，这样才能更有效的利用系统资源。

## 6. 扫码登录怎么实现

https://blog.csdn.net/j3T9Z7H/article/details/106009662

