# 智力题

[TOC]

https://www.jianshu.com/p/0aef53a3caf6

## 1. 有64匹马，一共有8个赛道，想要找出最快的4匹马，要比赛最少多少轮才可以?

- 第一步：全部马分为8组，每组8匹，每组各跑一次，然后淘汰掉每组的后四名，如下图（需要比赛8场）

![智力题_1](/Users/na/IdeaProjects/Technical summary/Image/智力题_1.png)

- 第二步：取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马，如下图（需要比赛1场）

![智力题_2](/Users/na/IdeaProjects/Technical summary/Image/智力题_2.png)

- 这个时候总冠军已经诞生，它就是A1，蓝色区域（它不需要比赛了），而其他可能跑得最快的三匹马只可能是下图中的黄色区域了（A2,A3,A4,B1,B2,B3,C1,C2,D1，共9匹马）

![智力题_3](/Users/na/IdeaProjects/Technical summary/Image/智力题_3.png)

- 第三步：只要从上面的9匹马中找出跑得最快的三匹马就可以了，但是现在只要8个跑道，怎么办？那就随机选出8匹马进行一次比赛吧（需要比赛一场）
- 第四步：上面比赛完，选出了前三名，但是9匹马中还有一匹马没跑呢，它可能是一个潜力股啊，那就和前三名比一比吧，这四匹马比一场，选出前三名。最后加上总冠军，跑得最快的四匹马诞生了！！！（需要一场比赛）
- 最后：一共需要11场

## 2. 9个人，一枚色子，选出两人，怎么比较公平？

![智力题_5](/Users/na/IdeaProjects/Technical summary/Image/智力题_5.jpeg)

## 3. 输入每个课程之间的关系，比如1->2，表示学习课程2需要先学习课程1，每轮学习课程 项目不限，问最快几轮学习完？

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 拓扑排序，入度数组
        int[] degree = new int[numCourses];

        for(int[] prerequisity : prerequisites){
            degree[prerequisity[0]]++;
        }

        Queue<Integer> q = new LinkedList<>();
        for(int i = 0; i < numCourses; i++){
            if(degree[i] == 0){
                q.offer(i);
            }
        }

        int count = 0;

        while(!q.isEmpty()){
            int size = q.size();

            for(int i = 0; i < size; i++){
                int curr = q.poll();

                for(int[] prerequisity : prerequisites){
                    if(prerequisity[1] == curr){
                        degree[prerequisity[0]]--;
                        if(degree[prerequisity[0]] == 0){
                            q.offer(prerequisity[0]);
                        }
                    }
                }
            }
            count++;
        }
        return count;
    }
}
```

## 4. 烧一根不均匀的绳子,从头烧到尾是要1个小时.现在有若干条材质相同的绳子 问如何用烧绳的方法来计时一个小时15分钟.

- 答案：把第一根绳子两头同时点燃,同时把第二根绳子点燃一头,当第一根绳子烧完时,时间为半个小时,这时把第二根绳子的另一头也点燃,开始计时,当第二根绳子烧完时,停止计时,那么这段时间就是15分钟。也就是说，只需要3根绳子就可以计时一个小时15分钟。
- 追问：
  1根两头烧，一根一头烧。当两头烧的烧完的时候就是半小时，此时立刻点燃那根一头烧的另一头，烧完就是45分钟。这根也烧完的时候立刻点燃第三根的两头，烧完就是75分钟。

## 5. 三门问题



## 6. 一硬币，一面向上概率0.7，一面0.3，如何公平？

连续抛两次硬币，正反面的出现有四种情况，概率依次为：

1. 两次均为正面：p * p
2. 第一次正面，第二次反面：p * (1 - p)
3. 第一次反面，第二次正面：(1 - p) * p
4. 两次均为反面：(1 - p) * (1 - p)

这不，中间两种情况的概率是完全一样的。于是问题的解法就是连续抛两次硬币，如果两次得到的相同则重新抛两次；否则根据第一次（或第二次）的正面反面情况，就可以得到两个概率相等的事件。

抛两次，正反A胜，反正B胜。

## 7. 两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率

每一轮抛硬币，A先抛赢得概率是1/2，B后抛赢得概率是（1/2）*（1/2）= 1/4。那么每一轮A赢得概率都是B赢得概率的2倍，总概率为1,所以A赢的概率是2/3。

## 8. 海盗分金币

### 8.1 在加勒比海上，有五个海盗，共同抢到了100枚金币， 每一个人按顺序依次提出自己的分配方案，如果提出的方案没有获得**半数或半数以上**的人的同意，则这个提出方案的人就被扔到海里喂鲨鱼，那么第一个提出方案的人要怎么做，才能使自己的利益最大化？

假使前三个人都因为分配金币的方式不合理而被扔下大海，此时还剩下两个人，也就是4号和5号，那么问题就简单了：

- 4号和5号分金币的情况：
      4号提出方案，自己一定会同意的，并且只要自己同意，这个方案就已经获得了半数的支持，就可以被实施
      因此，无论5号是否同意4号提出的方案，都不会对最终的结果造成影响，因此，4号一定会要100枚金币，以使自己的利益最大化，结果就变成了这样：
          4号        5号
          100        0
      
  现在我们多添加一个人，
- 3号，4号和5号分金币的情况：
      3号要使自己的提议获得半数的支持就必须再拉拢一个人，拉拢4号显然是不合适的，4号一定不会同意，4号知道，只要搞死了3号，剩下的100枚金币都是自己的。（就像上面4号和5号分金币的情况）拉拢5号是合适的，因为5号之前得不到金币，现在只要3号给5号一个金币就能够获得5号的支持，因为5号也知道，如果3号死亡，自己一定一枚金币都得不到。

情况就变成了这样：

​      3号        4号       5号
​      99           0          1

现在我们再多添加一个人：

- 2号，3号，4号和5号分金币的情况：
      2号要使自己的提议获得半数的支持也必须再拉拢一个人，拉拢3号显示是不合适的，3号一定不会同意，3号知道，只要搞死了2号，有99枚金币都是自己的（就像上面3号，4号和5号分金币的情况）， 拉拢5号貌似是可以的，他已经有一个金币了，要让他支持自己只要再多给他一个金币就可以了，拉拢4号也是可以的，4号现在没有金币，只要给他一个就可以让他自持自己的提案，综上所述，要让自己利益最大化，就需要拉拢4号，因为只要给4号一个金币即可：
      情况就变成了这样：
          2号        3号        4号        5号
          99           0            1        0
      
  最后我们再多添加一个人这道题目的答案就出来了：
- 1号，2号，3号，4号和5号分金币的情况：

1号要使自己的提议获得半数的支持必须拉拢两个人，拉拢2号显示是不合适的，2号一定不会同意，2号知道，只要搞死了1号，有99枚金币都是自己的，（就像上面2号，3号，4号和5号分金币的情况）， 拉拢4号貌似是可以的，他已经有一个金币了，要让他支持自己需要再给他一个金币才可以，这样做并不能让自己的利益最大化， 拉拢3号是可以的，3号现在没有金币，只要给他一个就可以让他自持自己的提案， 5号跟3号情况一至，同样没有金币，只要给他一个就可以了，综上所述，要让自己利益最大化，就需要拉拢3号跟5号，因为拉拢他们两个只需要各自给一个金币即可：
情况就变成了这样：
        1号        2号        3号        4号        5号
        98           0            1            0           1

### 8.2 超过半数同意方案才被通过,否则他将被扔入大海喂鲨鱼

##### 两个海盗--毫无悬念

很显然,当只有两个海盗的时候,一号一定会死,因为首先只要第一个海盗死了,剩下的一个便能获得全部的金币,根据==贪得无厌==的原则,二号也不会投同意票,即使一号选择
 ==(0,100)(即一号获得0个金币,二号获得100个)==,但是根据==心狠手辣==的原则,二号还是不会投同意票,所以此时无论如何也不会有半数以上的同意票,此时的一号表示:为什么我这么惨啊!

> 结果 (0, 100)

##### 三个海盗--无奈的选择

当存在三个海盗的时候,原来的两个海盗时的一号变成了二号,此时二号知道了,如果一号被投死,那么毫无悬念的,他没有任何活路,根据==贪生怕死==的原则,他会无论如何保全自己,换句话说,他无论如何都会同意此时一号的题意,那么此时聪明的一号知道他们的想法之后就开心的不行了,因为无论自己提什么条件自己都会得到半数以上的投票.那根据==贪得无厌==的原则,结果显而易见.

> 结果 (100, 0, 0)

##### 四个海盗--稍稍讨好就可以

四个海盗时,此时的一号明白了此时的二号是讨好不了的.因为自己死了二号就一定能得到全部100枚金币,所以干脆不讨好,给他0枚金币吧.而此时除了自己的票还差两票,那么只要讨好三号和四号获得这两票就好,三号和四号相当容易讨好的,因为一号死了,他们就只能得到空气(三个海盗的结果为(100, 0, 0)),那么给他一块金币就好啦.当然一号不能不给三号四号金币,因为海盗都是==心狠手辣==的,==[如果不管你死不死我都是0块金币,那我干脆要你死算了]==.

> 结果 (98, 0, 1, 1)

##### 五个海盗--照本宣科

相同的原理,现在的一号需要2票就能保证存活,首先二号是不考虑了给金币了,不管给多少都反对的,三号给一个金币就行,然后还差一票,只要给==四号或五号==其中一个两枚金币,另一个不给,就可以.但这里要注意一下,此时的分歧已经产生,后面的推广推理中会用到.

> 结果: (97, 0, 1, 2, 0)或(97, 0, 1, 0, 2)

到这里我们关于五个海盗分金币的问题就得到了完美的解决,看似最惨的一号海盗得到了最多的获利,令人侧目,可惜人不都是完全理性的,有时甚至愚蠢之极,但这或许就是社会令人难以着迷也最令人害怕的地方的地方.

------

#### 更多的推广和规律

五个海盗的故事结束了,现在来了六个海盗,

我们继续可以按照之前的思路分析现在的情况,一号需要3票,二号不能讨好,三号给一枚,四号五号六号呢,这就出现的不是很好理解的情况,我先说明最后的结果是:

> (97, 0, 1, 0, 1, 1)

为什么呢,我们可以从上面的推理发现我们其实一直没用到5.==疑心多虑==的原则,而现在就用到了,因为在五个海盗的时候有两种分法,四号和五号都可能分到2枚金币,也都可能分到0枚,他们不敢保证自己在这个人死后下一个人提方案时会给自己2枚还是0枚,那现在只要一号给他们一枚金币,他们就一定会投同意票
 ==(不信任彼此，尽量确保自身利益不寄希望与别人给自己更大利益)==.

所以这种分法是对一号收益最多的,否则他还要要花两枚金币去收买四号,一枚金币收买五六号中的一个 ==((96, 0, 1, 2, 0, 1)或(96, 0, 1, 2, 1, 0))==,这样不是最优的.

同样的思路推广下去我们会发现这样的规律:

> 当 n为偶数时只要给二号到n号0,1,0,1...0,1,0,1,1
>  当 n 为奇数时给1,x,1,x....x,x.(任意一个x是二其余都是0)

上述情况的答案都是m-n/2

## 9.  坐标系中有一个球桌，四个角坐标：(0,0), (0,4), (2,4), (2,0)，一颗球在(1,1)，请问从哪些角度可以射入洞内（可无限次碰撞）？

一般想法是将球镜像对称，但这道题是把洞镜像对称，将这个桌面在这个平面无限延展，可类比成无限张球桌紧密放置，那么每一个和球洞的连线都是合法路径

## 10. 54张扑克牌，平均分成3份，大小王在一份的概率

首先大王一定会在某一份中，然后要计算这一份中还要包含小王的概率。去掉大王还剩53张牌，这一份还可以分17张牌，那么每次分到小王的概率是1/53,所以总概率是17/53。

![智力题_4](/Users/na/IdeaProjects/Technical summary/Image/智力题_4.webp)

## 11. 田忌赛马

1、开始也是先排序，可以使用sort快排；

2、然后将田忌最大的马与国王进行比较；

3、如果田忌最大的马大于国王，那么就胜场++；

4、如果田忌最大的马小于国王，那么就一定会输，所以用田忌最小的马输给国王最大的马；

5、如果田忌最大的马等于国王，那么就比较最小的马；

5。1、如果田忌最小的马大于国王，那么胜场++；

5。2、如果田忌最小的马小于国王，那么就输给国王；

5。3、如果田忌最小的马等于国王，就用田忌最小的马对国王最大的马，如果国王最大的马大，那么财产要减200；

```java
            Collections.sort(list1); 
            Collections.sort(list2); 
       
            int i=0, j=0, x=n-1, y=n-1,count=0; 
            boolean bLast=true; 
       
            while(bLast)     
            { 
                //是否是最后一匹马 
                if(x==i) 
                    bLast=false; 
                   
                if(list1.get(x) > list2.get(y)) 
                {//如果田忌当前最好的马可以胜齐王最好的马，那么比一场 
                    x--; 
                    y--; 
                    count+=200; 
                } 
                else if(list1.get(i)> list2.get(j)) 
                {//如果田忌当前最差的马可以胜齐王最差的马，那么比一场 
                    i++; 
                    j++; 
                    count += 200; 
                } 
                else 
                {//否则，让田忌最差的马和齐王最好的好比一场 
                    if(list1.get(i) < list2.get(y)) 
                        count -= 200; 
                    i++; 
                    y--; 
                } 
            } 
```

## 12. 有容量为3L和5L的两个杯子，请使用这两个杯子量出4L水，水可以不限量的使用

1、用5L的杯子量出5L水

2、将这5L水倒入3L的杯子里，倒满之后，5L杯子还剩2L水

3、将3L杯子中的水倒掉

4、将5L杯子中的2L水全部倒进3L杯子里面，此时3L杯子还差1L就满了

5、用5L的杯子量出5L水，然后，将3L杯子灌满，因为3L杯子就差1L就慢，所以3L杯子灌满的时候，5L杯子中还剩4L水

# 场景题

## 1. 让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。

传入参数有总钱数，分的份数，随机分还是等分。先判断钱数能不能分那么多份，这个直接用总钱数>=0.01*份数判断就可以了。然后根据分发策略，选择随机还是等分，随机的话就给 1到总钱数-（总份数-1）*0.01 的随机数（总钱数以分为单位），等分的话直接除判断能不能除开，有余数就将余数加到最后一份里面。

## 2. 需求：谁关注了我，我关注了谁，谁与我互相关注。表该如何设计，索引怎么建。查询语句怎么写

粉丝关注表使用四列，主键id，userId，fansId，是否互相关注。用两行数据来保存互相的关注关系，这样查询起来更方便，用空间换时间。

主键有主键索引，剩下的字段不适合建索引，因为字段重复太多。

## 3. 分布式多个机器生成id，如何保证不重复?

1.snowflake方案：

snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。

优点：

1.毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。

2.不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。

3.可以根据自身业务特性分配bit位，非常灵活。

缺点：

强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。

2.用Redis生成ID：

因为Redis是单线程的，也可以用来生成全局唯一ID。可以用Redis的原子操作INCR和INCRBY来实现。

此外，可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis，可以初始化每台Redis的值分别是1,2,3,4,5，步长都是5，各Redis生成的ID如下：

A：1,6,11,16

B：2,7,12,17

C：3,8,13,18

D：4,9,14,19

E：5,10,15,20

这种方式是负载到哪台机器提前定好，未来很难做修改。3~5台服务器基本能够满足需求，都可以获得不同的ID，但步长和初始值一定需要事先确定，使用Redis集群也可以解决单点故障问题。

另外，比较适合使用Redis来生成每天从0开始的流水号，如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。

优点：

1）不依赖于数据库，灵活方便，且性能优于数据库。

2）数字ID天然排序，对分页或需要排序的结果很有帮助。

缺点：

1）如果系统中没有Redis，需要引入新的组件，增加系统复杂度。

2）需要编码和配置的工作量较大。

## 4. LRU算法怎么设计

使用LinkedHashMap可以实现，相对于HashMap,增加了双向链表，用于记录节点之间的先后顺序。LinkedHashMap的构造函数提供了一个参数accessOrder，这个参数可以指定链表是按照插入顺序排队还是按照访问顺序排队。参数为true时，就是按照访问顺序（插入，查询）排队，每次访问后这个节点就会被放到链表头，而长时间不被访问的节点逐渐就到了列表尾部，当需要淘汰时，就将链表尾部的节点抛弃。

## 5. 数据库连接池怎么设计

需要考虑的问题：

1. 限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源。
2. 当客户请求连接，而连接池中所有连接都已被占用时，该如何处理呢？一种方式是让客户一直等待，直到有空闲连接，另一种方式是为客户分配一个新的临时连接。
3. 当客户不再使用连接，需要把连接重新放回连接池。
4. 连接池中允许处于空闲状态的连接的最大项目。假定允许的最长空闲时间为十分钟，并且允许空闲状态的连接最大数目为5，

那么当连接池中有n个(n>5)连接处于空闲状态的时间超过十分钟时，就应该把n-5个连接关闭，并且从连接池中删除，这样才能更有效的利用系统资源。

## 6. 扫码登录怎么实现

https://blog.csdn.net/j3T9Z7H/article/details/106009662

## 7. 布隆过滤器：在海量数据中查找某个数据是否存在

- 在实际工作中，布隆过滤器常见的应用场景如下：

  - 网页爬虫对 URL 去重，避免爬取相同的 URL 地址；
  - 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；
  - Google Chrome 使用布隆过滤器识别恶意 URL；
  - Medium 使用布隆过滤器避免推荐给用户已经读过的文章；
  - Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找。 除了上述的应用场景之外，布隆过滤器还有一个应用场景就是解决缓存穿透的问题。所谓的缓存穿透就是服务调用方每次都是查询不在缓存中的数据，这样每次服务调用都会到数据库中进行查询，如果这类请求比较多的话，就会导致数据库压力增大，这样缓存就失去了意义。
- 利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不能完全解决，我们只能将其控制在一个可以容忍的范围内。
- 原理：布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0。为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。当对值进行搜索时，与哈希表类似，我们将使用 3 个哈希函数对 ”搜索的值“ 进行哈希运算，并查看其生成的索引值。
- 布隆过滤器可以检查值是 **“可能在集合中”** 还是 **“绝对不在集合中”**。“可能” 表示有一定的概率，也就是说可能存在一定为误判率。误报的情形产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。幸运的是，布隆过滤器有一个可预测的误判率（FPP）。极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 true 。这也就意味着 布隆过滤器的长度m 的选择取决于期望预计添加元素的数量 n ，并且 m 需要远远大于 n 。
- **当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中**。

## 8. 1亿个数中找出最大的100个数（top K问题）

-  最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求（我机器内存都是8GB），该方法也并不高效，因为题目的目的是寻找出最大的10000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。
- 第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的10000个数还小，那么容器内这个10000个数就是最大10000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。
- 第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100 * 10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。
- 第四种方法是Hash法。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。
- 第五种方法采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。