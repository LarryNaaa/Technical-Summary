# 多线程

## 1. 线程创建方式

![Thread](/Users/na/IdeaProjects/Technical summary/Image/Thread.png)

## 2. Thread方法

![States of a Thread](https://pic2.zhimg.com/v2-54ad049834f12e2f839f14c51fab3299_b.jpg)

![Thread_1](/Users/na/IdeaProjects/Technical summary/Image/Thread_1.png)

### 2.1 sleep(long millis)

指定毫秒数让当前正在执行的线程休眠

### 2.2 yield()

通知scheduler当前线程愿意放弃对CPU的使用

### 2.3 join()

等待当前线程死亡，在一个线程中调用另一个线程的join方法意味着当前线程等待直到另一个线程执行完毕



**面试题：如何保证三个线程a，b，c按顺序完成？**

**按顺序调用三个线程的join方法。**

## 3. synchronized

**1. synchronized锁的是对象不是代码，保证了原子性和可见性**

**2. 不要用String常量和基础数据类型的封装类**

### 3.1 对象锁

![Thread_2](/Users/na/IdeaProjects/Technical summary/Image/Thread_2.png)

### 3.2 类对象锁：锁的是某个类进行类加载时生成的Class对象

![Thread_3](/Users/na/IdeaProjects/Technical summary/Image/Thread_3.png)

![Thread_4](/Users/na/IdeaProjects/Technical summary/Image/Thread_4.png)

**面试题：模拟银行账户，对业务写方法加锁，对业务读方法不加锁，行不行？**

**不行，容易发生脏读。**

### 3.3 synchronized是可重入锁

一个同步方法可以调用另一个同步方法，一个线程已经拥有了某个对象的锁，再次申请时还会得到这个对象的锁。

父类和子类中的同步方法是共用的同一个对象。

### 3.4 出现异常，锁释放

![Thread_5](/Users/na/IdeaProjects/Technical summary/Image/Thread_5.png)

### 3.5 锁的级别

![CAS_2](/Users/na/IdeaProjects/Technical summary/Image/CAS_2.png)

一个线程访问：偏向锁

多个线程竞争：自旋锁、轻量级锁

自旋10次后、竞争激烈：重量级锁

