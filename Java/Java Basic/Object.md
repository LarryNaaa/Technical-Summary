# Object

## Methods

### equals()
**equals() is a method of Object class, it used to compare the addresses of two objects.**
```java
public boolean equals(Object obj) {
        return (this == obj);
    }
```

**If we want to compare the contents of two objects, we need to override .equals() method:**

1. check the address of two objects, if equal, return true
2. check the data type of two objects, using keyword instanceof
3. check the content as needed, if equal, return true

**String class has already overriden its .equals() method.**
```java
public boolean equals(Object anObject) {
	    // 1. check the address of two objects, if equal, return true
        if (this == anObject) {
            return true;
        }
        // 2. check the data type of two objects, using keyword instanceof
        if (anObject instanceof String) {
        	// 3. check the content as needed, if equal, return true
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        // otherwise, return false
        return false;
    }
``` 

#### What is the difference between == operator and .equals() method?
##### == operator
**For primitive types, we use == for content comparison; For objects, we use == for address comparison**, == checks if both objects point to the same memory location.

##### .equals() method
**For objects, we use .equals() method for content comparison**, .equals() evaluates to the comparison of values in the objects.

If a class does not override the equals method, then by default it uses equals(Object o) method of the closest parent class that has overridden this method. 

### hashCode()
**hashCode() returns an integer value, generated by a hashing algorithm.**

The contract between equals() and hashCode() is:
1. **If two objects are equal, then they must have the same hash code.**
2. **If two objects have the same hash code, they may or may not be equal.**

The idea behind a Map is to be able to find an object faster than a linear search. Using hashed keys to locate objects is a two-step process. Internally, the HashMap is implemented as an array of Entry objects. Each Entry has a pair and a pointer pointing to the next Entry. The hash code of the key object is the index for addressing the array. This locates the linked list of Entries in that cell of the array. The linked list in the cell is then searched linearly by using equals() to determine if two objects are equal.

The default implementation of hashCode() in Object class returns distinct integers for different objects. Therefore, the second apple has a different hash code.

The HashMap is organized like a sequence of buckets. The key objects are put into different buckets. It takes time of O(1) to get to the right bucket because it is an array access with the index. Therefore, it's a good practice to evenly distribute the objects into those buckets, i.e., having a hashCode() method that produces evenly distributed hash code. (Not the main point here though)

### finalize method
**It is a method that the Garbage Collector always calls just before the deletion/destroying the object** which is eligible for Garbage Collection, so as to perform clean-up activity.

in our class clean-up activities are there, then **we have to override this method to define our own clean-up activities.**

```java
class Hello { 
    public static void main(String[] args) 
    { 
        String s = new String("RR"); 
        s = null; 
  
        // Requesting JVM to call Garbage Collector method 
        System.gc(); 
        System.out.println("Main Completes"); 
    } 
  
    // Here overriding finalize method 
    public void finalize() 
    { 
        System.out.println("finalize method overriden"); 
    } 
} 
```

### clone()
Cloning is a process of creating an exact copy of an existing object in the memory. In java, clone() method of java.lang.Object class is used for cloning process. This method creates an exact copy of an object on which it is called through field-by-field assignment and returns the reference of that object. Not all the objects in java are eligible for cloning process. The objects which implement Cloneable interface are only eligible for cloning process. Cloneable interface is a marker interface which is used to provide the marker to cloning process. Click here to see more info on clone() method in java.

Both shallow copy and deep copy are related to this cloning process. The default version of clone() method creates the shallow copy of an object. To create the deep copy of an object, you have to override the clone() method.

#### Shallow Copy
The default version of clone() method creates the shallow copy of an object. The shallow copy of an object will have exact copy of all the fields of original object. If original object has any references to other objects as fields, then only references of those objects are copied into clone object, copy of those objects are not created. That means any changes made to those objects through clone object will be reflected in original object or vice-versa. Shallow copy is not 100% disjoint from original object. Shallow copy is not 100% independent of original object.

![Shallow Copy](https://i0.wp.com/javaconceptoftheday.com/wp-content/uploads/2015/04/ShallowCopy.png?w=1200)

#### Deep Copy
Deep copy of an object will have exact copy of all the fields of original object just like shallow copy. But in additional, if original object has any references to other objects as fields, then copy of those objects are also created by calling clone() method on them. That means clone object and original object will be 100% disjoint. They will be 100% independent of each other. Any changes made to clone object will not be reflected in original object or vice-versa.

![Deep Copy](https://i2.wp.com/javaconceptoftheday.com/wp-content/uploads/2015/04/DeepCopy.png?w=1200)

#### What is the difference between shallow copy and depy copy
1. Cloned Object and original object are not 100% disjoint in shallow copy, but they are 100% disjoint in deep copy.
2. Any changes made to cloned object will be reflected in original object or vice versa in shallow copy, but they are not in deep copy.
3. Default version of clone method creates the shallow copy of an object, to create the deep copy of an object, we have to override clone method.
4. Shallow copy is preferred if an object has only primitive fields, deep copy is preferred if an object has references to other objects as fields.
5. Shallow copy is fast and also less expensive, Deep copy is slow and very expensive.

#### Example
```java
public class CloneTest {
    public static void main(String[] args) {
        // person1
        Person person1 = new Person();
        person1.name = "Fred";
        Address add1 = new Address();
        add1.street = "Main Street";
        person1.address = add1;
        System.out.println("Before Change: " + person1);

        Person person2 = new Person();
        try{
            person2 = (Person) person1.clone();

        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }

        System.out.println("Before Change: " + person2);

        // change person1
        person1.name = "Bob";
        person1.address.street = "Front Str";
        System.out.println("After Change: " + person1);
        System.out.println("After Change: " + person2);

        System.out.println(person1.address == person2.address ? "clone is shallow copy" : "clone is deep copy");
    }
}


class Person implements Cloneable{
    public String name;
    public Address address;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        // pc2 with shallow copy
        return super.clone();

        // pc2 with deep copy
//        PersonClone person = (PersonClone) super.clone();
//        person.address = (AddressClone) this.address.clone();
//        return person;
    }

    @Override
    public String toString() {
        return "PersonClone{" +
                "name='" + name + '\'' +
                ", address=" + address +
                '}';
    }
}

class Address implements Cloneable{
    public int houseId;
    public String street;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public String toString() {
        return "AddressClone{" +
                "houseId=" + houseId +
                ", street='" + street + '\'' +
                '}';
    }
}
```







