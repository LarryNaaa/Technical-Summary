# HTTP

## 1. HTTP 是什么？描述一下

HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。

## 2. 能否详细解释「超文本传输协议」？

- **HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

## 3. 那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」 ，这种说法正确吗？

- 这种说法是**不正确**的。因为也可以是「服务器< -- >服务器」，所以采用**两点之间**的描述会更准确。

## 4. HTTP 常见的状态码，有哪些？

![HTTP_1](/Users/na/IdeaProjects/Technical summary/Image/HTTP_1.webp)

- *1xx* 

  `1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

- *2xx*

  `2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

  「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。

  「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

  「**206 Partial Content**」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

- *3xx*

  `3xx` 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

  「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。

  「**302 Temporarily Permanently**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

  301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

  「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

- *4xx*

  `4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

  「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。

  「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。

  「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

- *5xx*

  `5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

  「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

  「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。

  「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

  「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

## 5. http 常见字段有哪些？

- *Host*：客户端发送请求时，用来指定服务器的域名。有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。
- *Content-Length 字段*：服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。
- *Connection 字段*：`Connection` 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。
- *Content-Type 字段*：`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。
- *Content-Encoding 字段*：`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

## 6. 说一下 GET 和 POST 的区别？

- `Get` 方法的含义是请求**从服务器获取资源**，这个资源可以是静态的文本、页面、图片视频等。
- `POST` 方法则是相反操作，它向 `URI` 指定的资源提交数据，数据就放在报文的 body 里。

## 7. GET 和 POST 方法都是安全和幂等的吗？区别？

- 先说明下安全和幂等的概念：

  - 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。

  - 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。
- 那么很明显 **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。
- get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造；而 post 方法是把参数放在请求体 body 中的，这对用户来说不可见。
- get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。
- get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。
- get 请求在浏览器反复的 `回退/前进` 操作是无害的，而 post 操作会再次提交表单请求。
- get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。

## 8. 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？

### 8.1 优点

- HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。
- HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**。HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。
- *应用广泛和跨平台*

### 8.2 缺点

- 无状态
  - 无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
  - 无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。
- *明文传输*
  - 明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。
  - 在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取
- *不安全*
  - 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
  - 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
  - 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**
  - HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

### 8.3 那你说下 HTTP/1.1 的性能如何？

- *长连接*
  - **长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
  - 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
- *管道(pipeline)网络传输*
  - 即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**
  - 但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。
- *队头阻塞*
  - 因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」。

## 9. HTTP 与 HTTPS 有哪些区别？

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- HTTP 的端口号是 80，HTTPS 的端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## 10. HTTPS 解决了 HTTP 的哪些问题？

- HTTP 由于是明文传输，所以安全上存在以下三个风险：
  - **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
  - **篡改风险**，比如强制入垃圾广告，视觉污染，用户眼容易瞎。
  - **冒充风险**，比如冒充淘宝网站，用户钱容易没。
- HTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议。可以很好的解决了上述的风险：
  - **信息加密**：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
  - **校验机制**：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
  - **身份证书**：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。

![HTTP_2](/Users/na/IdeaProjects/Technical summary/Image/HTTP_2.webp)

## 11. HTTPS 是如何解决上面的三个风险的？

- 通过**混合加密**的方式可以保证信息的**机密性**，解决了窃听的风险。HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：

  - 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
  - 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

  采用「混合加密」的方式的原因：

  - **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
  - **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

- **摘要算法**用来实现**完整性**，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。

  - 客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的指纹和当前算出的指纹做比较，若指纹相同，说明数据是完整的。
  
- *数字证书*借助第三方权威机构 `CA` （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

## 12. HTTPS  是如何建立连接的？其间交互了什么？

- SSL/TLS 协议基本流程：

  - 客户端向服务器索要并验证服务器的公钥。
  - 双方协商生产「会话秘钥」。
  - 双方采用「会话秘钥」进行加密通信。

  前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。

  SSL/TLS 的「握手阶段」涉及**四次**通信，可见下图：

  ![HTTP_12](/Users/na/IdeaProjects/Technical summary/Image/HTTP_12.webp)

- 在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程

- ClientHello：客户端通过向服务器发送 `hello` 消息来发起握手过程。这个消息中会夹带着客户端支持的 `TLS 版本号(TLS1.0 、TLS1.2、TLS1.3)` 、客户端支持的密码套件、以及一串 `客户端随机数`。

- ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。

- 认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 `Certificate` 报文，报文中包含公开密钥证书。最后服务器发送 `ServerHelloDone` 作为 `hello` 请求的响应。第一部分握手阶段结束。

- `加密阶段`：在第一个阶段握手完成后，客户端会发送 `ClientKeyExchange` 作为响应，这个响应中包含了一种称为 `The premaster secret` 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 `ChangeCipherSpec`，告诉服务端使用私钥解密这个 `premaster secret` 的字符串，然后客户端发送 `Finished` 告诉服务端自己发送完成了。

  ## 13. TCP/IP 网络模型

  ![HTTP_4](/Users/na/IdeaProjects/Technical summary/Image/HTTP_4.png)

- OSI 七层网络模型，它就是在五层协议之上加了**表示层和会话层**

![HTTP_5](/Users/na/IdeaProjects/Technical summary/Image/HTTP_5.png)

- **HTTPS**：HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。

![HTTP_6](/Users/na/IdeaProjects/Technical summary/Image/HTTP_6.png)

## 14. 什么是无状态协议，HTTP 是无状态协议吗，怎么解决

- `无状态协议(Stateless Protocol)` 就是指**浏览器对于事务的处理没有记忆能力**。
- HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。
- 当你向服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 Set-Cookie：JSESSIONID=XXXXXXX 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 JSESSIONID=XXXXXXX 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；

![HTTP_7](/Users/na/IdeaProjects/Technical summary/Image/HTTP_7.png)

- 接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。
- 还有一种方式是使用 JWT 机制，它也是能够让你的浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点
  - JWT 的 Cookie 信息存储在`客户端`，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。
  - JWT 支持跨域认证，Cookies 只能用在`单个节点的域`或者它的`子域`中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过`多个节点`进行用户认证，也就是我们常说的`跨域认证`。

## 15. UDP 和 TCP 的区别

- TCP 和 UDP 都位于计算机网络模型中的运输层，它们负责传输应用层产生的数据。

### 15.1 UDP 是什么

- UDP 的全称是 `User Datagram Protocol`，用户数据报协议。它不需要所谓的`握手`操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。数据报是与分组交换网络关联的传输单元。
- UDP 的特点主要有
  - UDP 能够支持容忍数据包丢失的带宽密集型应用程序
  - UDP 具有低延迟的特点
  - UDP 能够发送大量的数据包
  - UDP 能够允许 DNS 查找，DNS 是建立在 UDP 之上的应用层协议。

### 15.2 TCP 是什么

- TCP 的全称是`Transmission Control Protocol` ，传输控制协议。它能够帮助你确定计算机连接到 Internet 以及它们之间的数据传输。通过三次握手来建立 TCP 连接，三次握手就是用来启动和确认 TCP 连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。
- TCP 的主要特点有
  - TCP 能够确保连接的建立和数据包的发送
  - TCP 支持错误重传机制
  - TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送
  - TCP 能够提供错误校验和，甄别有害的数据包。

### 15.3 TCP 和 UDP 的不同

![HTTP_8](/Users/na/IdeaProjects/Technical summary/Image/HTTP_8.png)

### 15.4 TCP 三次握手：TCP 的连接过程

![HTTP_9](/Users/na/IdeaProjects/Technical summary/Image/HTTP_9.png)

- SYN：它的全称是 `Synchronize Sequence Numbers`，同步序列编号。是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立 TCP 连接时，首先会发送的一个信号。客户端在接受到 SYN 消息时，就会在自己的段内生成一个随机值 X。
- SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。
- ACK：`Acknowledge character`, 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。

![HTTP_10](/Users/na/IdeaProjects/Technical summary/Image/HTTP_10.webp)

### 15.5 TCP 四次挥手：TCP 的释放过程

- 首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将 FIN 发送到服务器，并进入 `FIN_WAIT_1` 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的 ACK 响应。
- 然后第二步，当服务器收到 FIN 消息时，服务器会立刻向客户端发送 ACK 确认消息。
- 当客户端收到服务器发送的 ACK 响应后，客户端就进入 `FIN_WAIT_2` 状态，然后等待来自服务器的 `FIN` 消息
- 服务器发送 ACK 确认消息后，一段时间（可以进行关闭后）会发送 FIN 消息给客户端，告知客户端可以进行关闭。
- 当客户端收到从服务端发送的 FIN 消息时，客户端就会由 FIN_WAIT_2 状态变为 `TIME_WAIT` 状态。处于 TIME_WAIT 状态的客户端允许重新发送 ACK 到服务器为了防止信息丢失。客户端在 TIME_WAIT 状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源（包括端口号和缓冲区数据）都被释放。

![HTTP_11](/Users/na/IdeaProjects/Technical summary/Image/HTTP_11.png)

## 16. 地址栏输入 URL 发生了什么

- 首先，你需要在浏览器中的 URL 地址上，输入你想访问的地址
- 然后，浏览器会根据你输入的 URL 地址，去查找域名是否被本地 DNS 缓存，不同浏览器对 DNS 的设置不同，如果浏览器缓存了你想访问的 URL 地址，那就直接返回 ip。如果没有缓存你的 URL 地址，浏览器就会发起系统调用来查询本机 `hosts` 文件是否有配置 ip 地址，如果找到，直接返回。如果找不到，就向网络中发起一个 DNS 查询。
- 首先，查询请求会先找到本地 DNS 服务器来查询是否包含 IP 地址，如果本地 DNS 无法查询到目标 IP 地址，就会向根域名服务器发起一个 DNS 查询。
- 第三步，浏览器需要和目标服务器建立 TCP 连接，需要经过三次握手的过程，具体的握手过程请参考上面的回答。
- 在建立连接后，浏览器会向目标服务器发起 `HTTP-GET` 请求，包括其中的 URL，HTTP 1.1 后默认使用长连接，只需要一次握手即可多次传输数据。
- 如果目标服务器只是一个简单的页面，就会直接返回。但是对于某些大型网站的站点，往往不会直接返回主机名所在的页面，而会直接重定向。返回的状态码就不是 200 ，而是 301,302 以 3 开头的重定向码，浏览器在获取了重定向响应后，在响应报文中 Location 项找到重定向地址，浏览器重新第一步访问即可。
- 然后浏览器重新发送请求，携带新的 URL，返回状态码 200 OK，表示服务器可以响应请求，返回报文。