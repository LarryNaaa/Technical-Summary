# JVM面试题

## 1. 类加载子系统(Class Loader Subsystem) 

- 类加载子系统负责从文件系统或者网络中加载.class文件(字节码文件)，加载的类信息存放于一块叫做方法区的内存空间。

- 类加载的过程：
  
  - ### 加载(Loading)
  
    - 通过一个类的全限定明获取定义此类的二进制字节流；
    - 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据；
    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
  
  - #### 验证(Verify)
  
    - 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
    - 主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。
  
  - #### 准备(prepare)
  
    - 为类变量分配内存并且设置该类变量的默认初始值，即零值；
    - 这里不包含用final修饰的sttic，因为final在编译的时候就会分配了，准备阶段会显式初始化；
    - 之类不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到java堆中。
  
  - #### 解析(Resolve)
  
    - 将常量池内的符号引用转换为直接引用的过程。
    - 事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行
    - 符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
    - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。
  
  - ### 初始化(Initialize)
  
    - 初始化阶段就是执行类构造器方法clinit（）的过程。
    - 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 `我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法`
    - 构造器方法中指令按语句在源文件中出现的顺序执行
    - clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的init()）
    - 若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕
    - 虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。
  
- 类加载器分类：分别为**引导类加载器（BootStrap ClassLoader）\**和\**自定义类加载器（User-Defined ClassLoader）**

  - 启动类加载器（引导类加载器，BootStrap ClassLoader）**
    - 这个类加载使用**C/C++语言实现的**，嵌套在JVM内部
    - 它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
    - 并不继承自java.lang.ClassLoader,没有父加载器
    - 加载拓展类和应用程序类加载器，并指定为他们的父加载器
    - 处于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类
  - 拓展类加载器（Extension ClassLoader）**
  
    - java语言编写 ，由sun.misc.Launcher$ExtClassLoader实现。
    - 派生于ClassLoader类
    - 父类加载器为启动类加载器
    - 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。**如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载**
  - 应用程序类加载器（系统类加载器，AppClassLoader）**
  
    - java语言编写， 由sun.misc.Launcher$AppClassLoader实现。
    - 派生于ClassLoader类
    - 父类加载器为拓展类加载器
    - 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库
    - **该类加载器是程序中默认的类加载器**，一般来说，java应用的类都是由它来完成加载
    - 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器
  
- 双亲委派机制：避免类的重复加载，保护程序安全，防止核心API被随意篡改

  - 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。
  - 采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。
  
- 沙箱安全机制

  - **自定义String类，由于双亲委派机制加载这个自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是\**沙箱安全机制\**.**
  
- 判断两个class对象是同一个类

  - 类的完整类名必须一致，包括包名
  - 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同

## 2. 程序计数器(Program Counter Register)：线程私有

- PC寄存器是当前线程所执行的字节码的行号指示器，用来存储指向下一条指令的地址。
- 是线程私有的，生命周期与线程的生命周期保持一致。
- 程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）。
- 没有OOM，也不会出现GC垃圾回收。
- 使用PC寄存器存储字节码指令地址有什么用呢？/ 为什么使用PC寄存器记录当前线程的执行地址呢？
  - 因为CPU需要不停的切换各个线程，在切换回该线程时，CPU需要知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
- PC寄存器为什么会设定为线程私有？
  - 多线程在一个特定的时间段内会执行其中某一个线程的方法，CPU会不停地在不同的任务中切换，这样必然会导致经常中断或恢复，**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

## 3. 虚拟机栈(JVM Stack)：线程私有

- 是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
- 如果采用固定大小的Java虚拟机栈，如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 **StackOverFlowError**异常；如果java虚拟机栈可以动态拓展，尝试扩展时无法得到足够的内存或创建新线程时没有足够的内存去创建对应的虚拟机栈，将会抛出一个 **OutOfMemoryError异常**。
- 使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）
- 栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁。
  - 局部变量表（Local Variables）：**定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。
    - **最基本的存储单元是Slot(变量槽)**，**32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。**
    - 如果当前帧是由构造方法或者实例方法创建的，那么**该对象引用this将会存放在index为0的slot处**
    - 局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。
  - 操作数栈（Operand Stack）：**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。**
    - 在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）
    - 32bit的类型占用一个栈单位深度，64bit的类型占用两个栈深度单位。
    - **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令。
  - 动态链接（Dynamic Linking）：每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。
    - 在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**
    - 当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
    - 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。
    - 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法：**静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法**
  - 方法返回地址（Return Address）：存放调用该方法的PC寄存器的值。
    - 一个方法的结束，有两种方式：正常执行完成；出现未处理的异常，非正常退出
    - 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。**而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

## 4. 本地方法栈：线程私有

- 本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务
-  HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

## 5. 堆(Heap)：线程共享

- 是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。
- -Xms 用于表示堆的起始内存，-Xmx 用于设置堆的最大内存
- JDK 7以前： 新生区+养老区+永久区；JDK 8以后： 新生区+养老区+元空间
- 默认-XX：NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
- Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1，通过选项 -XX:SurvivorRatio 调整空间比例
- 对象晋升老年代的年龄阈值，默认是15次。可以设置参数：-XX:MaxTenuringThreshold=进行设置。
- 新生代：是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。
  - Eden区：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
  - Survivor0区(from区)：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
  - Survivor1区(to区)：保留了一次 MinorGC 过程中的幸存者。
- 老年代：主要存放应用程序中生命周期长的内存对象。
- MinorGC：采用复制算法对年轻代进行GC，会引发STW
  - eden 快满的触发因素有两个，一个是为对象分配内存不够，一个是为 TLAB 分配内存不够。
  - 首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）
  - 然后，清空 Eden 和 ServicorFrom 中的对象
  - 最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。
- Major GC：采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。
  - 会引发STW
  - 在进行 MajorGC 前一般都先进行了一次 MinorGC
- Full GC：回收整个堆，包括年轻代、老年代，如果有永久代的话还包括永久代。
  - 在要进行 young gc 的时候，根据之前统计数据发现年轻代平均晋升大小比现在老年代剩余空间要大，那就会触发 full gc。
  - 有永久代的话如果永久代满了也会触发 full gc。
  - 老年代空间不足，大对象直接在老年代申请分配，如果此时老年代空间不足则会触发 full gc。
  - 担保失败即 promotion failure，新生代的 to 区放不下从 eden 和 from 拷贝过来对象，或者新生代对象 gc 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 full gc。
  - 执行 System.gc()、jmap -dump 等命令会触发 full gc。
- mixed gc：这个是 G1 收集器特有的，指的是收集整个年轻代和部分老年代的 GC。
- TLAB（Thread Local Allocation Buffer）：JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内，使用TLAB可以避免一系列的非线程安全问题和对象分配时的竞争。这个区域只允许这一个线程申请分配对象，允许所有线程访问这块内存区域。
- 堆是分配对象的唯一选择么（不是）
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

## 6. 方法区(Method Area)：线程共享

- 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
- 在jdk7及以前，习惯上把方法区称为永久代。jdk8开始，使用元空间取代了永久代。元空间不再虚拟机设置的内存中，而是使用本地内存。
- 

