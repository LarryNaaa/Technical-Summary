# JVM面试题

## 1. 类加载子系统(Class Loader Subsystem) 

- 类加载子系统负责从文件系统或者网络中加载.class文件(字节码文件)，加载的类信息存放于一块叫做方法区的内存空间。

- 类加载的过程：
  
  - ### 加载(Loading)
  
    - 通过一个类的全限定明获取定义此类的二进制字节流；
    - 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据；
    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
  
  - #### 验证(Verify)
  
    - 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
    - 主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。
  
  - #### 准备(prepare)
  
    - 为类变量分配内存并且设置该类变量的默认初始值，即零值；
    - 这里不包含用final修饰的sttic，因为final在编译的时候就会分配了，准备阶段会显式初始化；
    - 之类不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到java堆中。
  
  - #### 解析(Resolve)
  
    - 将常量池内的符号引用转换为直接引用的过程。
    - 事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行
    - 符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
    - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。
  
  - ### 初始化(Initialize)
  
    - 初始化阶段就是执行类构造器方法clinit（）的过程。
    - 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 `我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法`
    - 构造器方法中指令按语句在源文件中出现的顺序执行
    - clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的init()）
    - 若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕
    - 虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。
  
- 类加载器分类：分别为**引导类加载器（BootStrap ClassLoader）\**和\**自定义类加载器（User-Defined ClassLoader）**

  - 启动类加载器（引导类加载器，BootStrap ClassLoader）**
    - 这个类加载使用**C/C++语言实现的**，嵌套在JVM内部
    - 它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
    - 并不继承自java.lang.ClassLoader,没有父加载器
    - 加载拓展类和应用程序类加载器，并指定为他们的父加载器
    - 处于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类
  - 拓展类加载器（Extension ClassLoader）**
  
    - java语言编写 ，由sun.misc.Launcher$ExtClassLoader实现。
    - 派生于ClassLoader类
    - 父类加载器为启动类加载器
    - 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。**如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载**
  - 应用程序类加载器（系统类加载器，AppClassLoader）**
  
    - java语言编写， 由sun.misc.Launcher$AppClassLoader实现。
    - 派生于ClassLoader类
    - 父类加载器为拓展类加载器
    - 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库
    - **该类加载器是程序中默认的类加载器**，一般来说，java应用的类都是由它来完成加载
    - 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器
  
- 双亲委派机制：避免类的重复加载，保护程序安全，防止核心API被随意篡改

  - 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。
  - 采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。
  
- 沙箱安全机制

  - **自定义String类，由于双亲委派机制加载这个自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是\**沙箱安全机制\**.**
  
- 判断两个class对象是同一个类

  - 类的完整类名必须一致，包括包名
  - 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同



