# JVM面试题

## 1. 类加载子系统(Class Loader Subsystem) 

- 类加载子系统负责从文件系统或者网络中加载.class文件(字节码文件)，加载的类信息存放于一块叫做方法区的内存空间。

- 类加载的过程：
  
  - ### 加载(Loading)
  
    - 通过一个类的全限定明获取定义此类的二进制字节流；
    - 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据；
    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
  
  - #### 验证(Verify)
  
    - 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
    - 主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。
  
  - #### 准备(prepare)
  
    - 为类变量分配内存并且设置该类变量的默认初始值，即零值；
    - 这里不包含用final修饰的sttic，因为final在编译的时候就会分配了，准备阶段会显式初始化；
    - 之类不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到java堆中。
  
  - #### 解析(Resolve)
  
    - 将常量池内的符号引用转换为直接引用的过程。
    - 事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行
    - 符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
    - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。
  
  - ### 初始化(Initialize)
  
    - 初始化阶段就是执行类构造器方法clinit（）的过程。
    - 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 `我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法`
    - 构造器方法中指令按语句在源文件中出现的顺序执行
    - clinit()不同于类的构造器。（关联：构造器是虚拟机视角下的init()）
    - 若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕
    - 虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。
  
- 类加载器分类：分别为**引导类加载器（BootStrap ClassLoader）\**和\**自定义类加载器（User-Defined ClassLoader）**

  - 启动类加载器（引导类加载器，BootStrap ClassLoader）**
    - 这个类加载使用**C/C++语言实现的**，嵌套在JVM内部
    - 它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
    - 并不继承自java.lang.ClassLoader,没有父加载器
    - 加载拓展类和应用程序类加载器，并指定为他们的父加载器
    - 处于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类
  - 拓展类加载器（Extension ClassLoader）**
  
    - java语言编写 ，由sun.misc.Launcher$ExtClassLoader实现。
    - 派生于ClassLoader类
    - 父类加载器为启动类加载器
    - 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。**如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载**
  - 应用程序类加载器（系统类加载器，AppClassLoader）**
  
    - java语言编写， 由sun.misc.Launcher$AppClassLoader实现。
    - 派生于ClassLoader类
    - 父类加载器为拓展类加载器
    - 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库
    - **该类加载器是程序中默认的类加载器**，一般来说，java应用的类都是由它来完成加载
    - 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器
  
- 双亲委派机制：避免类的重复加载，保护程序安全，防止核心API被随意篡改

  - 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。
  - 采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。
  
- 沙箱安全机制

  - **自定义String类，由于双亲委派机制加载这个自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是\**沙箱安全机制\**.**
  
- 判断两个class对象是同一个类

  - 类的完整类名必须一致，包括包名
  - 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同

## 2. 程序计数器(Program Counter Register)：线程私有

- PC寄存器是当前线程所执行的字节码的行号指示器，用来存储指向下一条指令的地址。
- 是线程私有的，生命周期与线程的生命周期保持一致。
- 程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）。
- 没有OOM，也不会出现GC垃圾回收。
- 使用PC寄存器存储字节码指令地址有什么用呢？/ 为什么使用PC寄存器记录当前线程的执行地址呢？
  - 因为CPU需要不停的切换各个线程，在切换回该线程时，CPU需要知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
- PC寄存器为什么会设定为线程私有？
  - 多线程在一个特定的时间段内会执行其中某一个线程的方法，CPU会不停地在不同的任务中切换，这样必然会导致经常中断或恢复，**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

## 3. 虚拟机栈(JVM Stack)：线程私有

- 是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
- 如果采用固定大小的Java虚拟机栈，如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 **StackOverFlowError**异常；如果java虚拟机栈可以动态拓展，尝试扩展时无法得到足够的内存或创建新线程时没有足够的内存去创建对应的虚拟机栈，将会抛出一个 **OutOfMemoryError异常**。
- 使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）
- 栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁。
  - 局部变量表（Local Variables）：**定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。
    - **最基本的存储单元是Slot(变量槽)**，**32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。**
    - 如果当前帧是由构造方法或者实例方法创建的，那么**该对象引用this将会存放在index为0的slot处**
    - 局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。
  - 操作数栈（Operand Stack）：**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。**
    - 在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）
    - 32bit的类型占用一个栈单位深度，64bit的类型占用两个栈深度单位。
    - **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，**并更新PC寄存器中下一条需要执行的字节码指令。
  - 动态链接（Dynamic Linking）：每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。
    - 在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**
    - 当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
    - 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。
    - 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法：**静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法**
  - 方法返回地址（Return Address）：存放调用该方法的PC寄存器的值。
    - 一个方法的结束，有两种方式：正常执行完成；出现未处理的异常，非正常退出
    - 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。**而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

## 4. 本地方法栈：线程私有

- 本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务
-  HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

## 5. 堆(Heap)：线程共享

- 是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。
- -Xms 用于表示堆的起始内存，-Xmx 用于设置堆的最大内存
- JDK 7以前： 新生区+养老区+永久区；JDK 8以后： 新生区+养老区+元空间
- 默认-XX：NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
- Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1，通过选项 -XX:SurvivorRatio 调整空间比例
- 对象晋升老年代的年龄阈值，默认是15次。可以设置参数：-XX:MaxTenuringThreshold=进行设置。
- 新生代：是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。
  - Eden区：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
  - Survivor0区(from区)：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
  - Survivor1区(to区)：保留了一次 MinorGC 过程中的幸存者。
- 老年代：主要存放应用程序中生命周期长的内存对象。
- MinorGC：采用复制算法对年轻代进行GC，会引发STW
  - eden 快满的触发因素有两个，一个是为对象分配内存不够，一个是为 TLAB 分配内存不够。
  - 首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）
  - 然后，清空 Eden 和 ServicorFrom 中的对象
  - 最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。
- Major GC：采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。
  - 会引发STW
  - 在进行 MajorGC 前一般都先进行了一次 MinorGC
- Full GC：回收整个堆，包括年轻代、老年代，如果有永久代的话还包括永久代。
  - 在要进行 young gc 的时候，根据之前统计数据发现年轻代平均晋升大小比现在老年代剩余空间要大，那就会触发 full gc。
  - 有永久代的话如果永久代满了也会触发 full gc。
  - 老年代空间不足，大对象直接在老年代申请分配，如果此时老年代空间不足则会触发 full gc。
  - 担保失败即 promotion failure，新生代的 to 区放不下从 eden 和 from 拷贝过来对象，或者新生代对象 gc 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 full gc。
  - 执行 System.gc()、jmap -dump 等命令会触发 full gc。
- mixed gc：这个是 G1 收集器特有的，指的是收集整个年轻代和部分老年代的 GC。
- TLAB（Thread Local Allocation Buffer）：JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内，使用TLAB可以避免一系列的非线程安全问题和对象分配时的竞争。这个区域只允许这一个线程申请分配对象，允许所有线程访问这块内存区域。
- 堆是分配对象的唯一选择么（不是）
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

## 6. 方法区(Method Area)：线程共享

- 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
- 在jdk7及以前，习惯上把方法区称为永久代。jdk8开始，使用元空间取代了永久代。元空间不再虚拟机设置的内存中，而是使用本地内存。
- 运行时常量池：常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
- 方法区的变化：
  - jdk1.6及之前：有永久代（permanent generation） ，静态变量存放在永久代上
  - jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中
  - jdk1.8及之后： 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆

![方法区_7](/Users/na/IdeaProjects/Technical summary/Image/方法区_7.webp)

![方法区_8](/Users/na/IdeaProjects/Technical summary/Image/方法区_8.webp)

![方法区_9](/Users/na/IdeaProjects/Technical summary/Image/方法区_9.webp)

- 永久代为什么要被元空间替换：为永久代设置空间大小是很难确定的。 在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。在元空间中，由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
- StringTable 为什么要调整：因为永久代的回收效率很低，在full gc的时候才会触发。而full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存.
- 方法区的垃圾回收：常量池中废弃的常量和不再使用的类型
  - 常量池之中主要存放的两大类常量：字面量和符号引用。只要常量池中的常量没有被任何地方引用，就可以被回收。
  - 判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
    - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
    - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
    - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 7. 创建对象

- 创建对象的方式:
  - new
    - 最常见的方式
    - 变形1 ： Xxx的静态方法
    - 变形2 ： XxBuilder/XxoxFactory的静态方法
  - Class的newInstance（）：反射的方式，只能调用空参的构造器，权限必须是public
  - Constructor的newInstance（Xxx）：反射的方式，可以调用空参、带参的构造器，权限没有要求
  - 使用clone（） ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）
  - 使用反序列化：从文件中、从网络中获取一个对象的二进制流
  - 第三方库Objenesis
  
- 创建对象的步骤:
  - 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。
  - 为对象分配内存
    1. 指针碰撞： 假设 Java 堆内存规整，利用一个指针将内存分为两部分，分配内存就是把指针向空闲方向挪动一段与对象大小相等的距离。
    2. 空闲列表：如果 Java 堆内存不规整，虚拟机维护一个列表记录可用内存，分配时从列表中找到一块足够的空间划分给对象并更新列表。
  - 处理并发安全问题：在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用 了两种方式解决并发问题：
    - CAS （ Compare And Swap ）失败重试、区域加锁：保证指针更新操作的原子性；
    - TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer） 虚拟机是否使用TLAB，可以通过一XX：+/一UseTLAB参数来 设定。
  - 初始化分配到的空间，所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用
  - 设置对象的对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。
  - 执行init方法进行初始化，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。
  
- 对象的内存布局：
  
  - 对象头（Header）包含两部分
  
    - 运行时元数据
      - 哈希值（ HashCode ）
      - GC分代年龄
      - 锁状态标志
      - 线程持有的锁
      - 偏向线程ID
      - 偏向时间戳
    - 类型指针：指向类元数据的InstanceKlass，确定该对象所属的类型
    - 说明：如果是数组，还需记录数组的长度
  - 实例数据（Instance Data）：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） 
  - 对齐填充：仅起占位符作用。虚拟机的内存管理系统要求任何对象的大小必须是 8B 的倍数，如果没有对齐需要对齐填充补全。
  
-  对象的访问定位
  
  - 直接指针(HotSpot采用)
  
  ![创建对象的方式_4](/Users/na/IdeaProjects/Technical summary/Image/创建对象的方式_4.webp)
  
  - 句柄访问
  
  ![创建对象的方式_3](/Users/na/IdeaProjects/Technical summary/Image/创建对象的方式_3.webp)
  
  ![创建对象的方式_5](/Users/na/IdeaProjects/Technical summary/Image/创建对象的方式_5.png)

## 8.直接内存

- 不是虚拟机运行时数据区的一部分，是Java堆外的、直接向系统申请的内存区间
- 直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值一Xmx参数值一致

## 9. 执行引擎

- 将字节码指令解释/编译为对应平台上的本地机器指令
- 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码
- **解释器**：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行(将字节码文件逐行转为机器码执行)，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
  - 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。
    - Interpreter模块：实现了解释器的核心功能
    - Code模块：用于管理HotSpot VM在运行时生成的本地机器指令
- **JIT （Just In Time Compiler）编译器（即时编译器）**：就是虚拟机将将字节码文件直接编译成机器码。
- 当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
- 热点探测：HotSpot VM所采用的热点探测方式是基于计数器的热点探测
  - 方法调用计数器（Invocation Counter）：统计方法的调用次数
    - 它的默认阈值在Client 模式 下是1500 次，在Server 模式下是10000 次。超过这个阈值，就会触发JIT编译。
    - 这个阈值可以通过虚拟机参数一XX ：CompileThreshold来人为设定。
  - 回边计数器（BackEdge Counter）：统计循环体执行的循环次数
  - 当一个方法被调用时， 会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。
  - 热度的衰减（Counter Decay）：当超过一定的时间限度， 如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半。
- JIT分类：
  - -client： 指定Java虚拟机运行在Client模式下，并使用C1编译器；
    - C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。
    - C1编译器上主要有方法内联，去虚拟化、冗余消除。
      - 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
      - 去虚拟化：对唯一的实现类进行内联
      - 冗余消除：在运行期间把一些不会执行的代码折叠掉
  - -server： 指定Java虚拟机运行在Server模式下，并使用C2编译器。
    - C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。
    - C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2.上有如下几种优化：（server模式下才会有这些优化，64位系统默认就是server模式）
      - 标量替换：用标量值代替聚合对象的属性值
      - 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
      - 同步消除：清除同步操作，通常指synchronized
  - Java7版本之后，一旦开发人员在程序中显式指定命令“一server"时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。

## 10. 字符串常量池

- String Pool 是一个固定大小的Hashtable，字符串常量池中是不会存储相同内容的字符串。
- Java 6及以前，字符串常量池存放在永久代。Java 7将字符串常量池的位置调整到Java堆内。
- 调整的原因：永久代permSize默认比较小; 永久代的垃圾回收频率低;
- String的intern（）的使用

  - jdk1.6中，将这个字符串对象尝试放入字符串常量池。
    - ➢如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址
    - ➢如果没有，会把此对象复制一份，放入字符串常量池，并返回字符串常量池中的对象地址
  - Jdk1.7起，将这个字符串对象尝试放入字符串常量池。
    - ➢如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址
    - ➢如果没有，则会把对象的引用地址复制一份，放入字符串常量池，并返回字符串常量池中的引用地址

