# GC面试题

## 1. 什么是垃圾

垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

## 2. 为什么要垃圾回收

- 如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。
- 除了释放没用的对象，垃圾回收也可以清除内存里的碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM 将整理出的内存分配给新的对象。

## 3. 垃圾回收的标记阶段？算法？

- 在垃圾回收之前，首先要判断内存中对象是否存活，这个过程称为垃圾标记阶段。
- Java使用的是可达性分析算法，以根对象集合(GCRoots）为起始点，搜索被根对象集合所连接的目标对象是否可达。内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）。分析工作必须在一个能保障一致性的快照中进行，GC进行时必须“StopTheWorld"。
- Java没有使用引用计数算法，该算法为每个对象保存一个引用计数器属性，用于记录对象被引用的情况(对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收)。
- Java没有使用引用计数算法的原因是无法处理循环引用的问题，这会导致内存泄漏。Python的解决方法是手动解除和使用弱引用。

## 4. GC Roots包括哪些元素？

- 虚拟机栈中引用的对象，方法中使用到的参数、局部变量等。
- 本地方法栈内引用的对象。
- 方法区中类静态属性引用的对象，Java类的引用类型静态变量。
- 方法区中常量引用的对象，字符串常量池（string Table） 里的引用。
- 所有被同步锁synchronized持有的对象。
- Java虚拟机内部的引用，基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。
- 除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）。
  - ➢如果只针对Java堆中的某一块区域进行垃圾回收（比如：只对新生代GC），新生代的对象完全有可能被老年代的对象所引用，这时候就需要将老年代的对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。

## 5. finalize（）方法和对象的finalization

- 垃圾回收此对象之前，总会先调用这个对象的finalize（）方法。finalize（）方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。
- 应该交给垃圾回收机制调用，不要主动调用某个对象的finalize （）方法。原因是finalize（） 时可能会导致对象复活且finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（） 方法将没有执行机会。
-  **判定是否可以回收具体过程** 判定一个对象objA是否可回收，至少要经历两次标记过程：

1. 如果对象objA到GC Roots没有引用链，则进行第一次标记。
2. 进行筛选，判断此对象是否有必要执行finalize（）方法
   1. ①如果对 象objA没有重写finalize（）方法，或者finalize （）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
   2. ②如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F一Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。
   3. ③finalize（）方法是对象逃脱死亡的最后机会，稍后Gc会对F一Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。

## 6. 垃圾回收算法？

- 标记-清除算法(Mark一Sweep)：当堆中的有效内存空间被耗尽的时候，就会停止整个程序（stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。
  - 标记： Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
  - 清除： Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。
  - 缺点：效率不高，GC时需要STW，会产生内存碎片需要维护一个空闲列表。
- 复制算法(Copying)：将内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。
  - 优点：没有标记和清除的过程，效率高；复制后保证了空间的连续性，不会有内存碎片的问题
  - 缺点：需要两倍的内存空间；如果存活对象很多，垃圾对象很少，回收性价比很低
  - 应用场景：堆中的S0和S1
- 标记-压缩算法(Mark-Compact)：第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象，第二阶段将所有的存活对象压缩到内存的一端，按顺序排放，之后，清理边界外所有的空间。

  - 与标记一清除算法的区别：标记一清除算法是一种非移动式的回收算法，标记一压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
  - 标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。(使用指针碰撞)
  - 指针碰撞（Bump the Pointer ）：如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer） 。
  - 优点：消除了标记一清除算法当中，内存存在碎片的问题；消除了复制算法当中，使用两倍内存的高额代价。
  - 缺点：标记一整理算法效率要低于复制算法；移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。移动过程中，需要STW

|          | Mark-Sweep       | Mark-Compact   | Copying                             |
| -------- | ---------------- | -------------- | ----------------------------------- |
| 速度     | 中等             | 最慢           | 最快                                |
| 空间开销 | 少(但会堆积碎片) | 少(不堆积碎片) | 通常需要活对象的2倍大小(不堆积碎片) |
| 移动对象 | 否               | 是             | 是                                  |

- 分代收集算法(Generational Collecting)：不同生命周期的对象可以采取不同的收集方式，Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。
  - 年轻代（Young Gen）
    - 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
    - 这种情况==复制算法==的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。
  - 老年代（Tenured Gen）
    - 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
    - 这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记一清除或者是标记一清除与标记一整理的混合实现。
      - ➢Mark阶段的开销与存活对象的数量成正比。
      - ➢Sweep阶段的开销与所管理区域的大小成正相关。
      - ➢Compact阶 段的开销与存活对象的数据成正比。
- 增量收集算法：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。
- 分区算法：整个堆空间划分成连续的不同小区间，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

## 7. System.gc()？

- System.gc ()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收。
- System.gc()调用附带一个免责声明，无法保证马上触发GC。
- 编写性能基准时调用

## 8. 内存溢出与内存泄漏？

- 内存溢出(OOM)是没有空闲内存，并且垃圾收集器也无法提供更多内存
  - 没有空闲内存的情况：说明Java虚拟机的堆内存不够：
    -  可能存在内存泄漏问题；也很有可能就是堆的大小不合理(-Xms、-Xmx来调整)
    -  创建了大量大对象，并且长时间不能被垃圾收集器收集
- 内存泄漏(Memory Leak)是对象不会再被程序用到了，但是GC又不能回收他们的情况
  - 1、单例模式
    单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。
  - 2、一些提供close的资源未关闭导致内存泄漏：数据库连接（ dataSourse. getConnection()），网络连接（socket）和io连接必须手动close，否则是不能被回收的。

## 9. 什么是STW？

- Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应。
- ➢可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。
  - 分析工作必须在一个能确保一致性的快照中进行
  - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上V- - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

## 10. 并行与并发

- 并发(Concurrent)是指一个时间段中有几个程序都处于己启动运行到运行完毕之间，且这几个程序都是在同一个CPU上运行。
- 并行(Parallel)是指当系统有多个CPU，每个CPU执行一个进程，每个进程互不抢占CPU资源，可以同时进行。
- 二者对比

  - 并发，指的是多个事情，在同一时间段内同时发生了。
  - 并行，指的是多个事情，在同一时间点上同时发生了。
  - 并发的多个任务之间是互相抢占资源的。
  - 并行的多个任务之间是不互相抢占资源的。
  - 只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。
- 垃圾回收的并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
  - 如ParNew、 Parallel Scavenge、 Parallel Old；
- 垃圾回收的串行（Serial）
  - 相较于并行的概念，单线程执行。
  - 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。
- 垃圾回收的并发（Concurrent） ：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。

  - ➢用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；
  - ➢如： CMS、G1

## 11. 安全点与安全区域

- 安全点(Safepoint)：程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC
  - Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。
  - 抢先式中断： （目前没有虚拟机采用了） 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。
  - 主动式中断： 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。
- 安全区域(Safe Region)是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。
  - 1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会 忽略标识为Safe Region状态的线程；
  - 2、当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止； 

## 12. 四种引用

- 强引用（Strong Reference）：在Java语言中使用new操作符创建一个新的对象， 并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。
  - 强引用可以直接访问目标对象。
  - 强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。
  - 强引用可能导致内存泄漏。
- 软引用（Soft Reference） ：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
  - 当内存足够: 不会回收软引用的可达对象
  - 当内存不够时: 会回收软引用的可达对象
- 弱引用（Weak Reference） ：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
  - 在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。
  - 弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。 
- 虚引用（Phantom Reference） ：一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，它不能单独使用，也无法通过虚引用来获取被引用的对象。为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知(回收跟踪)。
  - 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。 
  - 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录。