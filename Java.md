# Java

## Modifiers
> We divide modifiers into two groups:
> > Access Modifiers - controls the access level
> 
> > Non-Access Modifiers - do not control access level, but provides other functionality.

### Access Modifiers
> For classes, we can use either public or default:
>
> > public: The class is accessible by any other class
>
> > default: The class is only accessible by classes in the same package. 
>This is used when you don't specify a modifier.

> For attributes, methods and constructors, we can use the one of the following:
>
> > public: The code is accessible for all classes
>
> > private: The code is only accessible within the declared class
>
> > default: The code is only accessible in the same package. This is used when you don't specify a modifier.
>
> > protected: The code is accessible in the same package and subclasses. 

### Non-Access Modifiers
> For classes, you can use either final or abstract:
>
> > final: The class cannot be inherited by other classes
>
> > abstract: The class cannot be used to create objects (To access an abstract class, it must be inherited from another class.

> For attributes and methods, you can use the one of the following:
>
> > final: Attributes and methods cannot be overridden/modified
>
> > static: Attributes and methods belongs to the class, rather than an object
>
> > abstract: Can only be used in an abstract class, and can only be used on methods. The method does not have a body, for example abstract void run();. The body is provided by the subclass (inherited from). 

## Keywords

### public
An access modifier used for classes, attributes, methods and constructors, making them accessible by any other class

### private
An access modifier used for attributes, methods and constructors, making them only accessible within the declared class

### protected
An access modifier used for attributes, methods and constructors, making them accessible in the same package and subclasses

### abstract
A non-access modifier. Used for classes and methods: An abstract class cannot be used to create objects (to access it, it must be inherited from another class). An abstract method can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from)

### static
A non-access modifier used for nested class(cannot be used for top level class),
 methods, attributes and code blocks. Static methods/attributes can be accessed without creating an object of a class
> static methods:
> > they belong to the current class, not to the object
>
> > they cannot be overridden
>
> > they can be called by classname directly
>
> > cannot use this and super keywords in them

> static attributes:
> > they can be shared by all instances, and do not depend on objects
> 
> > when JVM loads classes, the memory is only allocated once for them

> static code blocks:
> > they are used for program optimization
>
> > they only be executed once when class is loaded
>
> > if there are multiple static code blocks, they will be executed in sequence 

#### What is the difference between static nested class and inner class?
there are two kinds of class in Java, 
one is called **top level class** and other is called **nested class**. 

As name suggested top level class is a class which is declared in 
.java file and not enclosed under any other class. 

On other hand nested class is declared inside another class. 
The class which enclosed nested class is known as Outer class.

In Java programming language you can not make a top level class static. 
We can only make nested class either static or non static. 
If you make a nested class non static then it also referred as Inner class.

1. Nested static class doesn't need reference of Outer class 
but non static nested class or Inner class requires Outer class 
reference. We can not create instance of Inner class 
without creating instance of Outer class. But we can create instance of
static nested class directly.
   
2. Static nested class cannot access non static members. 
While Inner class can access both static and 
non static member of Outer class.

### final
A non-access modifier used for classes, attributes and methods, which makes them non-changeable (impossible to inherit or override)
	
### finally
Used with exceptions, a block of code that will be executed no matter if there is an exception or not

#### What is the difference between final and finally?
**final**: 

1. is a mom-modifier, used for classes, attributes and methods
2. makes classes, attributes and methods non-changeable (impossible to inherit or override)

**finally**:
1. used with exception
2. a block of code that will be executed no matter if there is an exception or not

### try
Creates a try...catch statement

### catch
Catches exceptions generated by try statements

### throw
Creates a custom error

### throws
Indicates what exceptions may be thrown by a method

#### What is the difference between throw and throws?
**throw**: 

1. Used to throw an exception for a method
2. Cannot throw multiple exceptions
3. throw is followed by an object (new type)
4. used inside the method

**throws**: 

1. Used to indicate what exception type may be thrown by a method
2. Can declare multiple exceptions
3. throws is followed by a class
4. and used with the method signature

## Exceptions
When executing Java code, different errors can occur: coding errors made by the programmer, errors due to wrong input, or other unforeseeable things.

When an error occurs, Java will normally stop and generate an error message. The technical term for this is: Java will throw an exception (throw an error).

### try/catch keyword
The **try** statement allows you to define a block of code to be tested for errors while it is being executed.

The **catch** statement allows you to define a block of code to be executed, if an error occurs in the try block.

The try and catch keywords come in pairs:
```java
try {
  //  Block of code to try
}
catch(Exception e) {
  //  Block of code to handle errors
}
```
### finally keyword
The **finally** statement lets you execute code, after try...catch, regardless of the result:
```java
public class MyClass {
  public static void main(String[] args) {
    try {
      int[] myNumbers = {1, 2, 3};
      System.out.println(myNumbers[10]);
    } catch (Exception e) {
      System.out.println("Something went wrong.");
    } finally {
      System.out.println("The 'try catch' is finished.");
    }
  }
}
```
### throw keyword
The **throw** statement allows you to create a custom error.

The **throw** statement is used together with an exception type. There are many exception types available in Java: ArithmeticException, FileNotFoundException, ArrayIndexOutOfBoundsException, SecurityException, etc:
```java
public class MyClass {
  static void checkAge(int age) {
    if (age < 18) {
      throw new ArithmeticException("Access denied - You must be at least 18 years old.");
    }
    else {
      System.out.println("Access granted - You are old enough!");
    }
  }

  public static void main(String[] args) {
    checkAge(15); // Set age to 15 (which is below 18...)
  }
}
```

## Abstraction
Hiding the internal implementation of the feature and only 
showing the functionality to the users. i.e. what it works (showing), 
how it works (hiding). 

Both abstract class and interface are used for abstraction.

### Abstract class
Abstract class: is a restricted class that cannot be used to create objects (to access the abstract class, it must be inherited from another class).

1. An abstract class is a class that is declared with abstract keyword.
2. An abstract class may or may not have all abstract methods. Some of them can be concrete methods.
3. Any class that contains one or more abstract methods must also be declared with abstract keyword.
4. There can be no object of an abstract class.That is, an abstract class can not be directly instantiated with the new operator.
5. An abstract class can have parametrized constructors and 
default constructor is always present in an abstract class, 
but they cannot be declared abstract methods.
6. A subclass of an abstract class must give a concrete implementation of an abstract method in an abstract class unless the subclass is also an abstract class.


For example: we  have a abstract class Animal, and we have a subclass Pig
which inherit from Animal, so we can create a Pig 
object to access the abstract class Animal.

An abstract class can have both abstract and regular methods:
```java
// Abstract class
abstract class Animal {
  // Abstract method (does not have a body)
  public abstract void animalSound();
  // Regular method
  public void sleep() {
    System.out.println("Zzz");
  }
}

// Subclass (inherit from Animal)
class Pig extends Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
}

class MyMainClass {
  public static void main(String[] args) {
    Pig myPig = new Pig(); // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}
```

### Abstract method
Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).

1. An abstract method is a method that is declared without 
an implementation，does not contain the body of the method
2. A method defined abstract must always be redefined in the subclass, thus making overriding compulsory OR either make subclass itself abstract.


> Why And When To Use Abstract Classes and Methods?
>
> To achieve security - hide certain details and only show the important details of an object.

### Interface
An interface in Java is an abstract type, a collection of abstract methods. A class inherits the abstract methods of an interface by inheriting the interface.

```java
// interface
interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void run(); // interface method (does not have a body)
}
```
To access the interface methods, the interface must be "implemented" (kinda like inherited) by another class with the implements keyword (instead of extends). The body of the interface method is provided by the "implement" class:
```java
// Interface
interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void sleep(); // interface method (does not have a body)
}

// Pig "implements" the Animal interface
class Pig implements Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
  public void sleep() {
    // The body of sleep() is provided here
    System.out.println("Zzz");
  }
}

class MyMainClass {
  public static void main(String[] args) {
    Pig myPig = new Pig();  // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}
```
> Notes on Interfaces:
>
> Like abstract classes, interfaces cannot be used to create objects (in the example above, it is not possible to create an "Animal" object in the MyMainClass)
>  
> Interface methods do not have a body - the body is provided by the "implement" class
> 
> On implementation of an interface, you must override all of its methods
> 
> Interface methods are by default abstract and public
> 
> Interface attributes are by default public, static and final
> 
> An interface cannot contain a constructor (as it cannot be used to create objects)

> Why And When To Use Interfaces?
> 
> It is used to achieve total abstraction.
> 
> Since java does not support multiple inheritance in case of class, but by using interface it can achieve multiple inheritance .
> 
> It is also used to achieve loose coupling.
> 
> Interfaces are used to implement abstraction.

> Why use interfaces when we have abstract classes?
> The reason is, abstract classes may contain non-final variables, whereas variables in interface are final, public and static.

### Difference between Abstract Class and Interface in Java
1. Keywords: A Java interface can be implemented using keyword “implements” and abstract class can be extended using keyword “extends”.
2. Type of methods: Interface can have only abstract methods. Abstract class can have abstract and non-abstract methods. From Java 8, it can have default and static methods also.
3. Type of variables: Abstract class can have final, non-final, static and non-static variables. Interface has only static and final variables.
4. Inheritance and Implementation: A class can only extend another class, but it can implements multiple interfaces. An interface can extend multiple interfaces and cannot implements any interface.
5. Abstract classes are abstractions to classes, interfaces are abstractions to behaviors; An abstract class is an abstraction of the entire class, including properties, behaviors; An interface abstracts the behavior (local) of a class.

### Why use interfaces when we have abstract classes?
1. An interface can extend another Java interface only, an abstract class can extend another Java class and implement multiple Java interfaces.
2. abstract classes may contain non-final variables, whereas variables in interface are final, public and static.

### How to choose abstract class or interface?
1. Use an abstract class if we have some functionality that we want it's
 subclasses to have. For instance, if we have a set of functions that we
  want all of the base abstract class's subclasses to have.
2. Use an interface if we just want a general contract on 
behavior/functionality. If we have a function or object that we
 want to take in a set of different objects, use an interface. Then we
  can change out the object that is passed in, without changing 
  the method or object that is taking it.
3. If we want to create a base class without any method definitions or 
member variables, we should choose an interface.
4. Abstract classes should be chosen only when method definitions and member variables are required, because one or more methods that are concretely implemented are allowed in an abstract class.


## Overload
Overloading allows different methods to have the same name, 
but different signatures where the signature can differ by the 
number of input parameters or type of input parameters or both. 

We don’t have to create and remember different names for functions doing the same thing.

## Override
Overriding is about same function, same signature but different classes connected through inheritance.


Overriding is a feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes.

When a method in a subclass has the same name, same parameters or signature, and same return type(or sub-type) as a method in its super-class, then the method in the subclass is said to override the method in the super-class.

1. Overriding and Access-Modifiers : The access modifier for an overriding method can allow more, but not less, access than the overridden method. For example, a protected instance method in the super-class can be made public, but not private, in the subclass. Doing so, will generate compile-time error.

2. Final methods can not be overridden

3. Static methods can not be overridden

4. Private methods can not be overridden

5. The overriding method must have same return type (or subtype)

6. Invoking overridden method from sub-class : We can call parent class method in overriding method using super keyword.

7. Overriding and constructor : We can not override constructor as parent and child class can never have constructor with same name(Constructor name must always be same as Class name).


